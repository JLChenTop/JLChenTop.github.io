<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Web架构各层理解</title>
      <link href="/posts/20230815185446-316d88b8.html"/>
      <url>/posts/20230815185446-316d88b8.html</url>
      
        <content type="html"><![CDATA[<p>客户端从发送一个 HTTP 请求到 Flask 处理请求，分别经过了 web服务器层，WSGI层，web框架层，这三个层次。不同的层次其作用也不同</p><h1>Web服务器层</h1><p>对于传统的客户端 - 服务器架构，其请求的处理过程是，客户端向服务器发送请求，服务器接收请求并处理请求，然后给客户端返回响应。在这个过程中，服务器的作用是：</p><ol><li>接收请求</li><li>处理请求</li><li>返回响应</li></ol><p>Web服务器是一类特殊的服务器，其作用是主要是接收 HTTP 请求并返回响应。提起 web服务器大家都不会陌生，常见的 web服务器有 Nginx，Apache，IIS等。在上图1的三层结构中，web服务器是最先接收用户请求的，并将响应结果返回给用户。</p><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/2023/08/20230815-185917.awebp" alt="web服务器，web框架与WSGI的三层关系"></p><h1>Web应用框架层</h1><p>Web框架的作用主要是方便我们开发 web应用程序，HTTP请求的动态数据就是由 web框架层来提供的。常见的 web框架有Flask，Django等，我们以 Flask 框架为例子，展示 web框架的作用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():    </span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:    </span><br><span class="line">  app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">8080</span>)</span><br></pre></td></tr></table></figure><p>以上简单的几行代码，就创建了一个 web应用程序对象 <code>app</code>。<code>app</code> 监听机器所有 ip 的 8080 端口，接受用户的请求连接。我们知道，HTTP 协议使用 URL 来定位资源，上面的程序会将路径 <code>/hello</code> 的请求交由 <code>hello_world</code> 方法处理，<code>hello_world</code> 返回 ‘Hello World!’ 字符串。对于 web框架的使用者来说，他们并不关心如何接收            HTTP 请求，也不关心如何将请求路由到具体方法处理并将响应结果返回给用户。Web框架的使用者在大部分情况下，只需要关心如何实现业务的逻辑即可</p><h1>WSGI层</h1><p>Web Server Gateway Interface 的缩写，即 Web 服务器网关接口</p><p>WSGI 不是服务器，也不是用于与程序交互的API，更不是真实的代码，WSGI 只是一种接口,它只适用于 Python 语言，其全称为 Web Server Gateway Interface，定义了 web服务器和 web应用之间的接口规范。也就是说，只要 web服务器和 web应用都遵守WSGI协议，那么 web服务器和 web应用就可以随意的组合。下面的代码展示了 web服务器是如何与 web应用组合在一起的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">application</span>(<span class="params">env, start_response</span>):    </span><br><span class="line">  start_response(<span class="string">&#x27;200 OK&#x27;</span>, [(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html&#x27;</span>)])   </span><br><span class="line">  <span class="keyword">return</span> [<span class="string">b&quot;Hello World&quot;</span>]</span><br></pre></td></tr></table></figure><p>方法 <code>application</code>由 web服务器调用，参数<code>env</code>，<code>start_response</code> 由 web服务器实现并传入。其中，<code>env</code>是一个字典，包含了类似 HTTP_HOST，HOST_USER_AGENT，SERVER_PROTOCO 等环境变量。<code>start_response</code>则是一个方法，该方法接受两个参数，分别是<code>status</code>，<code>response_headers</code>。<code>application</code>方法的主要作用是，设置            http 响应的状态码和 Content-Type 等头部信息，并返回响应的具体结果。</p><p>上述代码就是一个完整的 WSGI 应用，当一个支持 WSGI 的 web服务器接收到客户端的请求后，便会调用这个 <code>application</code> 方法。WSGI 层并不需要关心<code>env</code>，<code>start_response</code> 这两个变量是如何实现的，就像在 <code>application</code> 里面所做的，直接使用这两个变量即可。</p><p>值得指出的是，WSGI 是一种协议，需要区分几个相近的名词：</p><ul><li>uwsgi<br>同 wsgi 一样也是一种协议，uWSGI服务器正是使用了 uwsgi 协议</li><li>uWSGI<br>实现了 uwsgi 和 WSGI 两种协议的web服务器。注意 uWSGI 本质上也是一种 web服务器，处于上面描述的三层结构中的 web服务器层。</li><li>CGI<br>通用网关接口，并不限于 Python 语言，定义了 web服务器是如何向客户端提供动态的内容。例如，规定了客户端如何将参数传递给 web服务器，web服务器如何将参数传递给 web应用，web应用如何将它的输出如何发送给客户端，等等。<br>生产环境下的 web应用都不使用 CGI 了，CGI进程（类似 Python 解释器）针对每个请求创建，用完就抛弃，效率低下。WSGI 正是为了替代 CGI 而出现的。</li></ul><p>说到这，我们基本理清了 WSGI 在 web服务器与 web框架之间作用：WSGI 就像一条纽带，将 web服务器与 web框架连接起来。回到本文的题目，Nginx 属于一种 web服务器，Flask属于一种 web框架，因此，WSGI 与 Nginx、Flask 的作用就不明而喻了。</p><p>最后以 Nginx，WSGI，Flask 之间的对话结束本文。<br><strong>Nginx</strong>：Hey，WSGI，我刚收到了一个请求，我需要你作些准备，然后由Flask来处理这个请求。<br><strong>WSGI</strong>：OK，Nginx。我会设置好环境变量，然后将这个请求传递给Flask处理。<br><strong>Flask</strong>：Thanks WSGI！给我一些时间，我将会把请求的响应返回给你。<br><strong>WSGI</strong>：Alright，那我等你。<br><strong>Flask</strong>：Okay，我完成了，这里是请求的响应结果，请求把结果传递给Nginx。<br><strong>WSGI</strong>：Good            job！Nginx，这里是响应结果，已经按照要求给你传递回来了。<br><strong>Nginx</strong>：Cool，我收到了，我把响应结果返回给客户端。大家合作愉快~</p><h1>为什么使用WSGI</h1><p>我们现在使用 Python 编写 Web 应用，</p><ul><li><p>可以用比较流行的 Flask、Django 框架，也可以按自己的想法直接写一个。</p></li><li><p>可选的服务器软件也特别多，比如常见的有 Apache、Nginx、IIS 等，</p></li><li><p>除此外，也有很多小众的软件。</p></li></ul><p>但是，现在问题来了，我该怎么部署？在没有 WSGI 规范之前，一个服务器调度 Python 应用是用这种方式，另一款服务器使用的是那种方式，这样的话，编写出来的应用部署时只能选择局限的某个或某些服务器，达不到通用的效果。</p><h1>只有python是WSGI</h1><p>WSGI（Web Server Gateway Interface）是Python的一种Web应用程序标准接口，它定义了Web服务器和用户程序之间的一种通信规范。</p><p>WSGI的出现是为了解决Python Web框架的兼容性问题，同时也使Python Web应用程序与多种Web服务器进行了兼容。</p><p>其他技术栈的Web框架与WSGI之间的关系可能会有所不同。</p><ul><li>比如JavaEE使用的是Servlet规范，而不是WSGI。</li><li>对于PHP，Apache一般采用mod_php方式运行，PHP和Apache之间的通信过程也与WSGI不同。</li><li>Node.js使用的是HTTP模块。 关于JavaEE容器和CGI/FastCGI，它们与WSGI有类似之处，都可以作为与Web服务器通信的中间件。</li><li>JavaEE容器会处理Servlet或JSP程序，而CGI/FastCGI会处理PHP、Perl等脚本语言。</li><li>不过，它们的使用场景不同，JavaEE容器和CGI/FastCGI大多用于处理动态生成的Web页面，而WSGI则更适用于处理Python Web应用的请求。</li></ul><p>总的来说，WSGI并不是Tomcat等JavaEE容器、CGI/FastCGI的替代实现，它只是一种Python Web应用程序标准接口。它的出现是为了使Python Web框架之间能够进行互操作，并且与多种Web服务器兼容。</p><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/2023/08/20230815-204155.jpg" alt="img"></p><h2 id="自定义实现web应用">自定义实现web应用</h2><p>上面的服务器和应用整体是跑起来了，那么我换一个服务器或者应用呢。由于服务器与应用之间怎么交互完全没有规范，比如服务器应该如何把请求信息传给应用，应用处理完毕后又怎么告诉服务器开始返回响应，如果都是各搞各的，服务器需要定制应用，应用也要定制服务器，这要一个应用能跑起来也太麻烦了点吧。</p><p>所以，WSGI 的出现就是为了解决上面的问题，它规定了服务器怎么把请求信息告诉给应用，应用怎么把执行情况回传给服务器，这样的话，服务器与应用都按一个标准办事，只要实现了这个标准，服务器与应用随意搭配就可以，灵活度大大提高。</p><h1>参考</h1><ul><li>转载<ol><li><a href="https://leehao.me/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3Nginx-WSGI-Flask%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/">如何理解Nginx, WSGI, Flask之间的关系 | Leo的博客 (leehao.me)</a></li><li>为什么只有Python有WSGI？ - 谈天吉皮提的回答 - 知乎 <a href="https://www.zhihu.com/question/598727285/answer/3009633117">https://www.zhihu.com/question/598727285/answer/3009633117</a></li><li><a href="https://zhuanlan.zhihu.com/p/44867546">说说我对 WSGI 的理解 - 知乎 (zhihu.com)</a></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web架构 </tag>
            
            <tag> WSGI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC框架</title>
      <link href="/posts/20230815155027-bfaf5b1d.html"/>
      <url>/posts/20230815155027-bfaf5b1d.html</url>
      
        <content type="html"><![CDATA[<h1>远程过程调用RPC</h1><p>RPC是一种<a href="https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1">进程间通信（IPC，Inter-Process Communication）</a>的一种技术，程序分布在不同的<a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4">地址空间</a>里。如果在同一主机里，RPC可以通过不同的虚拟地址空间（即便使用相同的物理地址）进行通讯，而在不同的主机间，则通过不同的物理地址进行交互。许多技术（通常是不兼容）都是基于这种概念而实现的。</p><ul><li><p>在采用C等古老语言编程的时候，RPC被称作了对S端的“子程序”的调用，所以称“过程调用”。在<a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B">面向对象编程</a>出现后，RPC也可以称为远程方法调用（RemoteMethodInvocation），或者远程调用（RemoteInvocation）例：<a href="https://zh.wikipedia.org/wiki/Java_RMI">Java RMI</a>。</p></li><li><p><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97">分布式计算</a>中，<strong>远程过程调用</strong>（英语：<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all，<strong>RPC</strong>）是一个计算机通信<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E7%B5%A1%E5%82%B3%E8%BC%B8%E5%8D%94%E8%AD%B0">协议</a>。该协议允许运行于一台计算机的<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F">程序</a>调用另一个<a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4">地址空间</a>（通常为一个开放网络的一台计算机）的<a href="https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F">子程序</a>，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。</p></li><li><p>RPC是一种服务器-客户端（Client/Server）模式，经典实现是一个通过<strong>发送请求-接受回应</strong>进行信息交互的系统。</p></li><li><p>RPC过程可以是同步的，也可以是异步的。<br>同步方式：C端向S端发送请求，阻塞等待；S端执行一段子程序，发送响应；C端继续执行；<br>异步方式，比如XHTTP调用。</p></li></ul><h2 id="信息传递">信息传递</h2><p>远程过程调用是一个<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97">分布式计算</a>的<a href="https://zh.wikipedia.org/wiki/%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8">客户端-服务器</a>（Client/Server）的例子，它简单而又广受欢迎。</p><p>远程过程调用总是由<a href="https://zh.wikipedia.org/wiki/%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a>对<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>发出一个执行若干过程请求，并用客户端提供的参数。执行结果将返回给客户端。由于存在各式各样的变体和细节差异，对应地派生了各式远程过程调用协议，而且它们并不互相兼容。</p><h2 id="流程">流程</h2><ol><li>客户端调用客户端stub（client stub）。这个调用是在本地，并将调用参数push到<a href="https://zh.wikipedia.org/wiki/%E6%A0%88">栈</a>（stack）中。</li><li>客户端stub（client stub）将这些参数包装，并通过系统调用发送到服务端机器。打包的过程叫 <a href="https://zh.wikipedia.org/wiki/Marshalling_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">marshalling</a>。（常见方式：<a href="https://zh.wikipedia.org/wiki/XML">XML</a>、<a href="https://zh.wikipedia.org/wiki/JSON">JSON</a>、二进制编码）</li><li>客户端本地操作系统发送信息至服务器。（可通过自定义<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">TCP协议</a>或<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a>传输）</li><li>服务器系统将信息传送至服务端stub（server stub）。</li><li>服务端stub（server stub）解析信息。该过程叫 <a href="https://zh.wikipedia.org/wiki/Unmarshalling_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">unmarshalling</a>。</li><li>服务端stub（server stub）调用程序，并通过类似的方式返回给客户端。</li></ol><h2 id="Stub">Stub</h2><p>Stub是一段代码，用来转换RPC过程中传递的参数。处理内容包括不同OS之间的大小端问题。另外，Client端一般叫Stub，Server端一般叫Skeleton。</p><p>生产方式：1）手动生成，比较麻烦；2）自动生成，使用IDL（InterfaceDescriptionLanguate），定义C/S的接口。</p><p>交互机制标准：一般采用IDL，生成IDL的工具 RPCGEN（）</p><p>为了允许不同的<a href="https://zh.wikipedia.org/wiki/%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a>均能访问<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>，许多标准化的 RPC 系统应运而生了。其中大部分采用<a href="https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80">接口描述语言</a>（Interface Description Language，IDL），方便<a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E5%B9%B3%E5%8F%B0">跨平台</a>的远程过程调用。</p><h1>RPC框架</h1><ul><li>Thrift</li><li></li></ul><h1>参考</h1><ul><li>转载</li></ul><ol><li><a href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8">远程过程调用 - 维基百科，自由的百科全书 (wikipedia.org)</a></li><li><a href="https://blog.csdn.net/soulofball/article/details/110087898">什么是RPC？RPC与Stub简述_rpc stub_wwj-jww的博客-CSDN博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> RPC框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web框架</title>
      <link href="/posts/20230815150034-51df7163.html"/>
      <url>/posts/20230815150034-51df7163.html</url>
      
        <content type="html"><![CDATA[<h1>什么是Web应用程序</h1><h2 id="Web的定义">Web的定义</h2><p>Web是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。<br>  是建立在Internet上的一种网络服务，为浏览者在Internet上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超链接将Internet上的信息节点组织成一个互为关联的网状结构，是运行在互联网上的一种分布式系统。</p><h2 id="Web的应用">Web的应用</h2><p><strong>网络应用程序</strong>（英语：web application，英文简称 <strong>Webapp</strong>）分为<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BE%9E%E5%BC%8F%E6%9E%B6%E6%A7%8B">客户端到服务器架构</a>或<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F">无服务器后端架构</a>。其中的客户端就是<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8%E6%AF%94%E8%BE%83">网页浏览器</a>。常见的网页应用程序有<a href="https://zh.wikipedia.org/wiki/Webmail">Webmail</a>、<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E8%B4%AD%E7%89%A9">网络购物</a>、<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E6%8B%8D%E8%B3%A3">网络拍卖</a>、<a href="https://zh.wikipedia.org/wiki/Wiki">wiki</a>、<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E8%AB%96%E5%A3%87">网络论坛</a>、<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%AA%8C">博客</a>、<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E9%81%8A%E6%88%B2">网络游戏</a>等诸多应用。</p><p>网络应用程序风行的原因之一，是因为可以直接在各种电脑平台上执行，不需要事先安装或定期升级等程序。</p><p>各种类型的<a href="https://zh.wikipedia.org/wiki/%E5%8B%95%E6%85%8B%E7%B6%B2%E9%A0%81">动态网页</a>和“网络应用程序” 之间的区别一般是不清楚的。<br>最有可能接近“网络应用程序”的网站是与<strong>桌面软件应用程序</strong>或<a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E5%8B%95%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F">移动应用程序</a>具有类似功能的网站。<br><a href="https://zh.wikipedia.org/wiki/HTML5">HTML5</a>引入了明确的支持，使得应用程序可以作为网页加载，可以在本地存储数据并在脱机状态下继续运行。</p><h3 id="分类">分类</h3><ul><li><p>普通网页应用程序</p></li><li><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8">单页应用</a>更类似于应用程序，因为它们没有使用不同的URL切换操作界面。像 <a href="https://zh.wikipedia.org/w/index.php?title=Sencha_Touch&amp;action=edit&amp;redlink=1">Sencha Touch</a> 和 <a href="https://zh.wikipedia.org/wiki/AngularJS">AngularJS</a> 这样的单页网页框架可能会被用来为移动平台开发这样的网页应用。</p></li></ul><h2 id="Web应用程序架构">Web应用程序架构</h2><p>目前流行Web应用程序架构有两种：C/S、B/S.<br>  C/S：Client/Server，服务器通常采用高性能的PC、工作站或小型机，客户端需要安装专用的客户端软件。<br>  B/S：Brower/Server，客户端只要安装一个浏览器，通过浏览器与Web服务器进行数据交互。</p><h1>Web应用框架</h1><h2 id="概述">概述</h2><p><strong>Web应用框架</strong>（Web application framework）是一种<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6">电脑</a><a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94%E6%A1%86%E6%9E%B6">软件框架</a>，用来支持<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8B%95%E6%85%8B%E7%B6%B2%E7%AB%99&amp;action=edit&amp;redlink=1">动态网站</a>、<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E7%B5%A1%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F">网络应用程序</a>及<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1">网络服务</a>的开发。这种框架有助于减轻网页开发时共通性活动的工作负荷，例如许多框架提供<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%BA%AB">数据库</a>存取接口、标准模板以及<a href="https://zh.wikipedia.org/wiki/%E6%9C%83%E8%A9%B1">会话</a>管理等，可提升代码的可再用性。</p><blockquote><ul><li><p>用于Web应用程序的开发，是建立 web 应用的一种方式</p></li><li><p>web 框架的目的：向程序员隐藏了处理 HTTP 请求和响应相关的基础代码。<br>至于隐藏多少这取决于不同的框架，Django 和 Flask 走向了两个极端：Django 包括了每种情形，几乎成了它致命的一点；Flask 立足于“微框架”，仅仅实现 web 应用需要的最小功能，其它的不常用的 web 框架任务交由第三方库来完成。</p></li><li><p>但是最后要记住的是，Python web 框架都以相同的方式工作的：它们接收 HTTP 请求，分派代码，产生 HTML，创建带有内容的 HTTP 响应。事实上，所有主流的服务器端框架都以这种方式工作的（ JavaScript 框架除外）</p></li></ul></blockquote><h2 id="框架种类">框架种类</h2><h3 id="模型-视图-控制器（MVC（Model-view-controller））">模型 - 视图 - 控制器（MVC（Model view controller））</h3><p>主条目：<a href="https://zh.wikipedia.org/wiki/MVC">MVC</a></p><p>许多框架遵循模型 - 视图 - 控制器（MVC）体系模型的结构模式，使数据模型与用户界面分开。这被普遍认为是一个很好的做法，因为它模块化的代码，能提高代码的重复使用，并允许多个接口。在Web应用中，这允许不同的应用方面，如网页，远程应用程序和Web服务接口。MVC是业界比较认可的架构模型。</p><h3 id="三部分组织模式">三部分组织模式</h3><p>在这种组织模式中，应用程序建立在三个部分：客户端，应用程序和数据库。数据库通常是一个RDBMS。而客户端指的是由Web应用程序生成的HTML，在用户的浏览器运行。应用程序运行在服务器上。</p><h3 id="内容管理系统（CMS）">内容管理系统（CMS）</h3><p>主条目：<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">内容管理系统</a></p><p>指的是一种内容编辑程序。就像在部落格写文章一样，不需要懂得编程的人，也可以通过CMS发布，更改，管理内容。</p><h2 id="各种编程语言Web框架">各种编程语言Web框架</h2><table><thead><tr><th>CL</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Php</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Python</td><td></td><td>Flask</td><td></td><td></td><td></td></tr><tr><td>Java</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Javascript</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h1>为什么要用Web框架</h1><h2 id="什么是Web-Framework？">什么是Web Framework？</h2><p>Web Application Framework（Web应用程序框架）或简单的Web Framework（Web框架）表示一个库和模块的集合，使Web应用程序开发人员能够编写应用程序，而不必担心协议，线程管理等低级细节。</p><h3 id="Web应用程序的本质">Web应用程序的本质</h3><p>Web(World Wide Web)诞生最初的目的，是为了利用互联网交流工作文档。</p><h3 id="使用WEB框架的优点">使用WEB框架的优点</h3><p>web网站发展至今，特别是<a href="https://cloud.tencent.com/product/cvm?from_column=20065&amp;from=20065">服务器</a>端，涉及到的知识、内容，非常广泛。这对程序员的要求会越来越高。如果采用成熟，稳健的框架，那么一些基础的工作，比如，安全性，数据流控制等都可以让框架来处理，那么程序开发人员可以把精力放在具体的业务逻辑上面。使用框架的优点： <strong>稳定性和可扩展性强</strong> <strong>可以降低开发难度，提高开发效率。</strong> 总结一句话：避免重复造轮子</p><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/2023/08/20230815-163129.png" alt="20190315163458696"></p><h1>参考</h1><ul><li>转载</li></ul><ol><li><a href="https://zh.wikipedia.org/zh-sg/Web%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6">Web应用框架 - 维基百科，自由的百科全书 (wikipedia.org)</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">网络应用程序 - 维基百科，自由的百科全书 (wikipedia.org)</a></li><li><a href="https://blog.csdn.net/qq_37020594/article/details/101380144">Web的定义和应用，及应用程序架构和技术分类_wed功能和技术架构_我的芒果的博客-CSDN博客</a></li><li><a href="https://www.cnblogs.com/hazir/p/what_is_web_framework.html">【译】什么是 web 框架？ - hazir - 博客园 (cnblogs.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> Web框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thrift学习</title>
      <link href="/posts/20230814224851-4964b695.html"/>
      <url>/posts/20230814224851-4964b695.html</url>
      
        <content type="html"><![CDATA[<h1>Thrift</h1><p><code>Thrift</code>是一个<strong>轻量级</strong>、<strong>跨语言</strong>的<strong>远程服务调用</strong>框架，最初由<code>Facebook</code>开发，后面进入<code>Apache</code>开源项目。它通过自身的<code>IDL</code><strong>中间语言</strong>, 并借助<strong>代码生成引擎</strong>生成各种主流语言的<code>RPC</code><strong>服务端</strong>/<strong>客户端</strong>模板代码。</p><p><code>Thrift</code>支持多种不同的<strong>编程语言</strong>，包括<code>C++</code>、<code>Java</code>、<code>Python</code>、<code>PHP</code>、<code>Ruby</code>等，本系列主要讲述基于<code>Java</code>语言的<code>Thrift</code>的配置方式和具体使用。</p><h2 id="Thrift-技术栈">Thrift 技术栈</h2><p><code>Thrift</code>对<strong>软件栈</strong>的定义非常的清晰, 使得各个组件能够<strong>松散的耦合</strong>, 针对不同的应用场景, 选择不同是方式去搭建服务。</p><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/2023/08/20230814-225601.awebp" alt="img"></p><p><code>Thrift</code><strong>软件栈</strong>分层<strong>从下向上</strong>分别为：<strong>传输层</strong>(<code>Transport Layer</code>)、<strong>协议层</strong>(<code>Protocol Layer</code>)、<strong>处理层</strong>(<code>Processor Layer</code>)和<strong>服务层</strong>(<code>Server Layer</code>)。</p><ul><li><strong>传输层</strong>(<code>Transport Layer</code>)：传输层负责直接从网络中<strong>读取</strong>和<strong>写入</strong>数据，它定义了具体的<strong>网络传输协议</strong>；比如说<code>TCP/IP</code>传输等。</li><li><strong>协议层</strong>(<code>Protocol Layer</code>)：协议层定义了<strong>数据传输格式</strong>，负责网络传输数据的<strong>序列化</strong>和<strong>反序列化</strong>；比如说<code>JSON</code>、<code>XML</code>、<strong>二进制数据</strong>等。</li><li><strong>处理层</strong>(<code>Processor Layer</code>)：处理层是由具体的<code>IDL</code>（<strong>接口描述语言</strong>）生成的，封装了具体的<strong>底层网络传输</strong>和<strong>序列化方式</strong>，并委托给用户实现的<code>Handler</code>进行处理。</li><li><strong>服务层</strong>(<code>Server Layer</code>)：整合上述组件，提供具体的<strong>网络线程/IO服务模型</strong>，形成最终的服务。</li></ul><h2 id="Thrift的特性">Thrift的特性</h2><h3 id="一-开发速度快">(一) 开发速度快</h3><p>通过编写<code>RPC</code>接口<code>Thrift IDL</code>文件，利用<strong>编译生成器</strong>自动生成<strong>服务端骨架</strong>(<code>Skeletons</code>)和<strong>客户端桩</strong>(<code>Stubs</code>)。从而省去开发者<strong>自定义</strong>和<strong>维护接口编解码</strong>、<strong>消息传输</strong>、<strong>服务器多线程模型</strong>等基础工作。</p><ul><li>服务端：只需要按照<strong>服务骨架</strong>即<strong>接口</strong>，编写好具体的<strong>业务处理程序</strong>(<code>Handler</code>)即<strong>实现类</strong>即可。</li><li>客户端：只需要拷贝<code>IDL</code>定义好的<strong>客户端桩</strong>和<strong>服务对象</strong>，然后就像调用本地对象的方法一样调用远端服务。</li></ul><h3 id="二-接口维护简单">(二) 接口维护简单</h3><p>通过维护<code>Thrift</code>格式的IDL（<strong>接口描述语言</strong>）文件（注意写好注释），即可作为给<code>Client</code>使用的接口文档使用，也<strong>自动生成</strong>接口代码，始终保持代码和文档的一致性。且<code>Thrift</code>协议可灵活支持<strong>接口</strong>的<strong>可扩展性</strong>。</p><h3 id="三-学习成本低">(三) 学习成本低</h3><p>因为其来自<code>Google Protobuf</code>开发团队，所以其<code>IDL</code>文件风格类似<code>Google Protobuf</code>，且更加<strong>易读易懂</strong>；特别是<code>RPC</code><strong>服务接口</strong>的风格就像写一个<strong>面向对象</strong>的<code>Class</code>一样简单。</p><p>初学者只需参照：<a href="https://link.juejin.cn?target=http%3A%2F%2Fthrift.apache.org%2F">thrift.apache.org/</a>，一个多小时就可以理解<code>Thrift IDL</code>文件的语法使用。</p><h3 id="四-多语言-跨语言支持">(四) 多语言/跨语言支持</h3><p><code>Thrift</code>支持<code>C++</code>、 <code>Java</code>、<code>Python</code>、<code>PHP</code>、<code>Ruby</code>、<code>Erlang</code>、<code>Perl</code>、<code>Haskell</code>、<code>C#</code>、<code>Cocoa</code>、<code>JavaScript</code>、<code>Node.js</code>、<code>Smalltalk</code>等多种语言，即可生成上述语言的<strong>服务器端</strong>和<strong>客户端程序</strong>。</p><p>对于我们经常使用的<code>Java</code>、<code>PHP</code>、<code>Python</code>、<code>C++</code>支持良好，虽然对<code>iOS</code>环境的<code>Objective-C</code>(<code>Cocoa</code>)支持稍逊，但也完全满足我们的使用要求。</p><h3 id="五-稳定-广泛使用">(五) 稳定/广泛使用</h3><p><code>Thrift</code>在很多开源项目中已经被验证是<strong>稳定</strong>和<strong>高效</strong>的，例如<code>Cassandra</code>、<code>Hadoop</code>、<code>HBase</code>等；国外在<code>Facebook</code>中有广泛使用，国内包括百度、美团小米、和饿了么等公司。</p><h2 id=""></h2><h1>对比HTTP</h1><p>和 http 相比，同属于应用层，走 tcp 协议。Thrift 优势在于发送同样的数据，request包 和 response包 要比 http 小很多，在整体性能上要优于 http 。</p><h1>Thrift学习</h1><p>如果使用thrift框架来调用别人的服务，则必须要知道别人写的.thrift文件.<br>.thrift文件，其实就是你要访问的服务的一份说明书，里面会定义服务的名称，以及该服务中的函数，以及函数的入参有几个，每个参数的数据类型是什么，参数的名称是啥，还有返回值的数据类型。</p><h2 id="Thrift实例">Thrift实例</h2><p>以python+thrift为例</p><p>环境准备：</p><ul><li>从官网上下载 windows 版的 thrift.exe：<a href="http://archive.apache.org/dist/thrift/0.9.3/">http://archive.apache.org/dist/thrift/0.9.3/</a> （我这里用的是0.9.3版本）</li><li>python版本：Python 3.7.1</li><li>pip3 install thrift</li></ul><ol><li>首先使用 thrift 之前需要定义一个 .thrift 格式的文件,比如 test.thrift</li></ol><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Transmit</span> </span>&#123;</span><br><span class="line"><span class="type">string</span> sayMsg(<span class="number">1</span>:<span class="type">string</span> msg);</span><br><span class="line"><span class="type">string</span> invoke(<span class="number">1</span>:<span class="type">i32</span> cmd <span class="number">2</span>:<span class="type">string</span> token <span class="number">3</span>:<span class="type">string</span> data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后运行命令：<code>thrift-0.9.3.exe -gen py test.thrift </code>生成 python 代码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thrift-0.9.3.exe -gen py test.thrift</span><br></pre></td></tr></table></figure><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/2023/08/20230814-230311.png" alt="img"></p><ol start="3"><li>然后将生成的 python 代码 和 文件，放到新建的 python 项目中。完成后先运行服务器代码,启动服务</li></ol><ul><li>服务端代码 <a href="http://server.py">server.py</a>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> Transmit</span><br><span class="line"><span class="keyword">from</span> test.ttypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> thrift.transport <span class="keyword">import</span> TSocket</span><br><span class="line"><span class="keyword">from</span> thrift.transport <span class="keyword">import</span> TTransport</span><br><span class="line"><span class="keyword">from</span> thrift.protocol <span class="keyword">import</span> TBinaryProtocol</span><br><span class="line"><span class="keyword">from</span> thrift.server <span class="keyword">import</span> TServer</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransmitHandler</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.log = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sayMsg</span>(<span class="params">self, msg</span>):</span><br><span class="line">        msg = json.loads(msg)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;sayMsg(&quot;</span> + msg + <span class="string">&quot;)&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;say &quot;</span> + msg + <span class="string">&quot; from &quot;</span> + socket.gethostbyname(socket.gethostname())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invoke</span>(<span class="params">self,cmd,token,data</span>):</span><br><span class="line">        cmd = cmd</span><br><span class="line">        token =token</span><br><span class="line">        data = data</span><br><span class="line">        <span class="keyword">if</span> cmd ==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> json.dumps(&#123;token:data&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;cmd不匹配&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    handler = TransmitHandler()</span><br><span class="line">    processor = Transmit.Processor(handler)</span><br><span class="line">    transport = TSocket.TServerSocket(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8000</span>)</span><br><span class="line">    tfactory = TTransport.TBufferedTransportFactory()</span><br><span class="line">    pfactory = TBinaryProtocol.TBinaryProtocolFactory()</span><br><span class="line">    server = TServer.TSimpleServer(processor, transport, tfactory, pfactory)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Starting python server...&quot;</span>)</span><br><span class="line">    server.serve()</span><br></pre></td></tr></table></figure><ol start="4"><li>客户端代码调用服务，以python调用为例</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> jsonfrom test <span class="keyword">import</span> Transmit</span><br><span class="line"><span class="keyword">from</span> test.ttypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> test.constants <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> thrift <span class="keyword">import</span> Thrift</span><br><span class="line"><span class="keyword">from</span> thrift.transport <span class="keyword">import</span> TSocket</span><br><span class="line"><span class="keyword">from</span> thrift.transport <span class="keyword">import</span> TTransport</span><br><span class="line"><span class="keyword">from</span> thrift.protocol <span class="keyword">import</span> TBinaryProtocol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">transport = TSocket.TSocket(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8000</span>)</span><br><span class="line">transport = TTransport.TBufferedTransport(transport)</span><br><span class="line">protocol = TBinaryProtocol.TBinaryProtocol(transport)</span><br><span class="line">client = Transmit.Client(protocol)</span><br><span class="line"><span class="comment"># Connect!</span></span><br><span class="line">transport.<span class="built_in">open</span>()</span><br><span class="line"></span><br><span class="line">cmd = <span class="number">2</span></span><br><span class="line">token = <span class="string">&#x27;1111-2222-3333-4444&#x27;</span></span><br><span class="line">data = json.dumps(&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;zhoujielun&quot;</span>&#125;)</span><br><span class="line">msg = client.invoke(cmd,token,data)</span><br><span class="line"><span class="built_in">print</span>(msg)</span><br><span class="line">transport.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果：cmd不匹配</span></span><br></pre></td></tr></table></figure><h1>参考</h1><ul><li>转载</li></ul><ol><li><a href="https://juejin.cn/post/6844903622380093447">Apache Thrift系列详解(一) - 概述与入门 - 掘金 (juejin.cn)</a></li><li><a href="https://www.cnblogs.com/shenh/p/10529073.html">python 使用 thrift 教程 - 三只松鼠 - 博客园 (cnblogs.com)</a></li><li><a href="https://juejin.cn/post/7071891920783409182">python：rpc框架之thrift框架 - 掘金 (juejin.cn)</a></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> RPC框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC框架 </tag>
            
            <tag> Thrift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask学习</title>
      <link href="/posts/20230814175838-95d3c49f.html"/>
      <url>/posts/20230814175838-95d3c49f.html</url>
      
        <content type="html"><![CDATA[<h1>什么是Flask</h1><h2 id="什么是Flask？">什么是Flask？</h2><p>Flask是一个用Python编写的Web应用程序框架。 它由 <strong>Armin Ronacher</strong> 开发，他领导一个名为Pocco的国际Python爱好者团队。 Flask基于Werkzeug WSGI工具包和Jinja2模板引擎。两者都是Pocco项目。</p><p>Flask诞生于2010年，是用Python语言基于Werkzeug工具箱编写的轻量级Web开发框架。</p><p>Flask本身相当于一个内核，其他几乎所有的功能都要用到扩展（邮件扩展Flask-Mail，用户认证Flask-Login），都需要用第三方的扩展来实现。</p><p>其 WSGI 工具箱采用 Werkzeug（路由模块），模板引擎则使用 Jinja2。这两个也是Flask框架的核心。</p><p>Python最出名的框架要数Django，此外还有Flask、Tornado等框架。虽然Flask不是最出名的框架，但是Flask应该算是最灵活的框架之一，这也是Flask受到广大开发者喜爱的原因。</p><h2 id="WSGI">WSGI</h2><p>Web Server Gateway Interface（Web服务器网关接口，WSGI）已被用作Python Web应用程序开发的标准。 WSGI是Web服务器和Web应用程序之间通用接口的规范。</p><h2 id="Werkzeug">Werkzeug</h2><p>它是一个WSGI工具包，它实现了请求，响应对象和实用函数。 这使得能够在其上构建web框架。 Flask框架使用Werkzeug作为其基础之一。</p><h2 id="jinja2">jinja2</h2><p>jinja2是Python的一个流行的模板引擎。Web模板系统将模板与特定数据源组合以呈现动态网页。</p><h1>Flask学习教程</h1><ul><li><a href="https://www.w3cschool.cn/flask/flask_overview.html#">Flask 概述_w3cschool</a></li></ul><h2 id="Flask程序例子">Flask程序例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>把它保存为 <a href="http://hello.py">hello.py</a> （或是类似的），然后用 Python 解释器来运行。 确保你的应用文件名不是 <a href="http://flask.py">flask.py</a> ，因为这将与 Flask 本身冲突。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python hello.py</span><br><span class="line"> * Running on http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在访问 <a href="http://127.0.0.1:5000/">http://127.0.0.1:5000/</a> ，你会 看见 Hello World 问候。</p><h3 id="那么，这段代码做了什么？">那么，这段代码做了什么？</h3><p>首先，我们导入了 Flask 类。这个类的实例将会是我 们的 WSGI 应用程序。</p><p>接下来，我们创建一个该类的实例，第一个参数是应用模块或者包的名称。 如果你使用单一的模块（如本例），你应该使用 <strong>name</strong> ，因为模块 的名称将会因其作为单独应用启动还是作为模块导入而有不同（ 也即是 ‘<strong>main</strong>’ 或实际的导入名）。这是必须的，这样 Flask 才知道到哪去找模板、静态文件等等。详情见 Flask 的文档。</p><p>然后，我们使用 route() 装饰器告诉 Flask 什么样 的URL 能触发我们的函数。</p><p>这个函数的名字也在生成 URL 时被特定的函数采用，这个函数返回我们想 要显示在用户浏览器中的信息。</p><p>最后我们用 run() 函数来让应用运行在本地服务器上。 其中 if <strong>name</strong> == ‘<strong>main</strong>’: 确保服务器只会在该脚本被 Python 解释器直接执行的时候才会运行，而不是作为模块导入的时候。</p><p>欲关闭服务器，按 Ctrl+C。</p><h3 id="外部可访问的服务器">外部可访问的服务器</h3><p>如果你运行了这个服务器，你会发现它只能从你自己的计算机上访问，网络 中其它任何的地方都不能访问。在调试模式下，用户可以在你的计算机上执 行任意 Python 代码。因此，这个行为是默认的。</p><p>如果你禁用了 debug 或信任你所在网络的用户，你可以简单修改调用 run() 的方法使你的服务器公开可用，如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.run(host=&#x27;0.0.0.0&#x27;)</span><br></pre></td></tr></table></figure><p>这会让操作系统监听所有公网 IP。</p><h1>参考</h1><ol><li><a href="https://www.w3cschool.cn/flask/flask_overview.html#">Flask 概述_w3cschool</a></li><li>[【一周掌握Flask框架学习笔记】Flask概念及基础-腾讯云开发者社区-腾讯云 (<a href="http://tencent.com">tencent.com</a>)</li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> Web框架 </category>
          
          <category> Python </category>
          
          <category> Flask </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> Web框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Select下拉选择onchange事件</title>
      <link href="/posts/20230810233351-9e5ae3e6.html"/>
      <url>/posts/20230810233351-9e5ae3e6.html</url>
      
        <content type="html"><![CDATA[<h1>Select下拉选择onchange事件</h1><ul><li>现在要实现这样一个效果<br>网页下拉选择选择，自动更新页面内容</li><li>下拉选择是select标签，自动更新页面内容，可以通过onchange事件实现</li></ul><h1>onchange定义</h1><p>当元素的值发生改变时，会发生 onchange 事件。</p><p>对于单选框和复选框，在被选择的状态改变时，发生 onchange 事件。</p><p>提示：该事件类似于 <a href="https://www.w3school.com.cn/jsref/event_oninput.asp">oninput 事件</a>。不同之处在于 oninput 事件在元素值改变后立即发生，而 onchange 在元素失去焦点而内容发生改变后发生。另一个区别是 onchange 事件也适用于 <code>&lt;select&gt;</code> 元素。</p><h1>使用</h1><p>有若干种方式</p><h2 id="1-在select标签-设置-onchange属性">1. 在select标签 设置 onchange属性</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>请从列表中选择一辆新车。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;mySelect&quot;</span> <span class="attr">onchange</span>=<span class="string">&quot;myFunction()&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Audi&quot;</span>&gt;</span>Audi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;BMW&quot;</span>&gt;</span>BMW<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Mercedes&quot;</span>&gt;</span>Mercedes<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Volvo&quot;</span>&gt;</span>Volvo<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>当您选择一辆新车时，会触发一个函数，输出所选汽车的值。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>You selected: <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> x = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;mySelect&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;You selected: &quot;</span> + x;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>如示下例</li></ul><!DOCTYPE html><html><body><p>请从列表中选择一辆新车。</p><select id="mySelect" onchange="myFunction()">  <option value="Audi">Audi</option>  <option value="BMW">BMW</option>  <option value="Mercedes">Mercedes</option>  <option value="Volvo">Volvo</option></select><p>当您选择一辆新车时，会触发一个函数，输出所选汽车的值。</p><p id="demo">You selected: </p><script>function myFunction() {  var x = document.getElementById("mySelect").value;  document.getElementById("demo").innerHTML = "You selected: " + x;}</script></body></html><h2 id="2-使用jQuery动态添加-onchange属性">2. 使用jQuery动态添加 onchange属性</h2><ul><li>引入jquery <code>&lt;script src=&quot;/js/jquery.min.js&quot;&gt;&lt;/script&gt;</code></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script src=<span class="string">&quot;/js/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;p&gt;请从列表中选择一辆新车。&lt;/p&gt;</span><br><span class="line">&lt;select id=<span class="string">&quot;mySelect2&quot;</span> &gt;</span><br><span class="line">  &lt;option value=<span class="string">&quot;Audi&quot;</span>&gt;Audi&lt;/option&gt;</span><br><span class="line">  &lt;option value=<span class="string">&quot;BMW&quot;</span>&gt;BMW&lt;/option&gt;</span><br><span class="line">  &lt;option value=<span class="string">&quot;Mercedes&quot;</span>&gt;Mercedes&lt;/option&gt;</span><br><span class="line">  &lt;option value=<span class="string">&quot;Volvo&quot;</span>&gt;Volvo&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;p&gt;当您选择一辆新车时，会触发一个函数，输出所选汽车的值。&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">&quot;demo2&quot;</span>&gt;You selected: &lt;/p&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">$( document ).ready(function() &#123;</span><br><span class="line">    $(<span class="string">&quot;#mySelect2&quot;</span>).change(function()&#123;</span><br><span class="line">      update();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  function <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">let</span> <span class="variable">mySelect2</span> <span class="operator">=</span> $(<span class="string">&quot;#mySelect2&quot;</span>).val();</span><br><span class="line">    console.log(<span class="string">&quot;You selected: &quot;</span> + mySelect2);</span><br><span class="line">    demo2.innerText = (<span class="string">&quot;You selected: &quot;</span> + mySelect2).toLocaleString();</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>如示下例</li></ul><!DOCTYPE html><html><body>  <script src="/js/jquery.min.js"></script><p>请从列表中选择一辆新车。</p><select id="mySelect2" >  <option value="Audi">Audi</option>  <option value="BMW">BMW</option>  <option value="Mercedes">Mercedes</option>  <option value="Volvo">Volvo</option></select><p>当您选择一辆新车时，会触发一个函数，输出所选汽车的值。</p><p id="demo2">You selected: </p><script type="text/javascript">$( document ).ready(function() {    $("#mySelect2").change(function(){      update();    })  })  function update() {    let mySelect2 = $("#mySelect2").val();    console.log("You selected: " + mySelect2);    demo2.innerText = ("You selected: " + mySelect2).toLocaleString();  }</script></body></html><h1>参考</h1><ol><li><a href="https://www.w3school.com.cn/jsref/event_onchange.asp">onchange 事件 (w3school.com.cn)</a></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> select标签 </tag>
            
            <tag> onchange </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回车换行详解</title>
      <link href="/posts/20230810180521-d0173ed6.html"/>
      <url>/posts/20230810180521-d0173ed6.html</url>
      
        <content type="html"><![CDATA[<h1>回车换行详解</h1><ul><li>原始的 回车(carriage return)和换行(line feed)是两个动作<ul><li>\n：表示换到下一行</li><li>\r  ：表示移动到行首</li></ul></li><li>现在 在计算机文件中，编程语言中<ul><li>\n：换行并移动到行首</li><li>\r：移动到行首</li></ul></li></ul><h2 id="1-机械打字机">1. 机械打字机</h2><p>“车(carriage)”是指纸车,带着纸一起左右移动的模块。</p><ul><li>回车：<br>在早期的机械打字机上，打印头是固定的，只能通过左右移动纸车在一行上打字。当开始打第一个字之前，要把纸车拉到最右边，上紧弹簧，随着打字，弹簧把纸车拉回去。每当打完一行后，纸车就完全收回去了，所以叫回车。<ul><li>换行：<br>打字机边上有个&quot;把手&quot;,往下扳动一下,纸会上移一行。在后来的电传打字机甚至今天的终端中都沿用了这些叫法。<br>YouTube上找了两个视频，一个是打印头固定的，一个是不固定的。可以看下，更容易理解：<ul><li><a href="https://www.youtube.com/watch?v=wf0a4tos3mk">固定打印头</a></li><li><a href="https://www.youtube.com/watch?v=lCZmVXGyVQQ">不固定打印头</a></li></ul></li></ul></li></ul><h2 id="2-电传打字机">2. 电传打字机</h2><p>​在后来的电传打字机中，通常打印头可以左右移动，这样可以节省空间，同时也就没有纸车这个概念了，不过车这个说法依然留下来了，只不过是指打印头，回车即将打印头回到行首，换行依然是将纸上移一行。</p><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/2023/08/20230810-182802.jpg" alt="ASR 33 Teletype Information"></p><ul><li><p>回车(<code>CR</code>)和换行(<code>LF</code>)的顺序问题<br>据<a href="https://en.wikipedia.org/wiki/Newline#History">wiki记载</a>，通常的电传打字机都是用<code>CR+LF</code>这个顺序，典型的就是上面那台<code>Teletype Model 33 ASR</code>。</p><p>把这一步骤拆分为回车和换行，是因为 <strong>打印头不能在一个字符的时间内从最右侧移动到下一行开始</strong> 。在<code>CR</code>之后打印的一个字符通常会变成污迹，由于打印头在移动到行首过程中，下个字符同时打印了。<br>所以解决办法就是将换行做成两个字符：<code>CR</code>将打印头移动到行首，<code>LF</code>进纸。事实上，通常还要发送额外的字符(额外的<code>CR</code>或者<code>NUL</code>，这些字符将被忽略)以保证打印头有足够的时间移动到行首。</p></li></ul><h2 id="3-计算机中打印字符">3. 计算机中打印字符</h2><ul><li>以下参考网上很多说法</li></ul><blockquote><ul><li><p>等到早期的计算机发明时，很自然的这两个概念被拿了过来。但是由于那时的存储设备非常昂贵，一些人认为在每行的结尾加两个字符用于换行，实在是极大的浪费，于是各个厂商在这一点上便出现了分歧。</p></li><li><p>windows: 由于一些早期的微型计算机还没有用于隐藏底层硬件细节的设备驱动，所以它们直接沿用了打字机的惯例，使用不带<code>NUL</code>的<code>CRLF</code>作为一个<code>EOL</code>。而CP/M为了和这些微型计算机使用同一个终端，也采用了这种设计。所以它的克隆MS-DOS也同样使用<code>CRLF</code>，由于Windows又是基于MS-DOS，为保持兼容性，所以就导致了如今的Windows是采用<code>CRLF</code>作为<code>EOL</code>，即<code>\r\n</code>(或<code>0x0D</code> <code>0x0A</code>)。</p></li><li><p>Unix: 而Multics在被设计之时就非常认真的考虑了这一问题，设计者们觉得只需一个字符便完全足够来表示<code>EOL</code>，这样更加合理。那么选择<code>CR</code>还是<code>LF</code>呢？本来由于那时的键盘上都有一个<code>Return</code>键，所以可能更好的选择是<code>CR</code>。但当时考虑到<code>CR</code>可以用来重写一行，以完成如<strong>粗体</strong>和<s>删除线</s>等效果，所以他们选择了稍稍难以理解的<code>LF</code>。然后自己设计了一个设备驱动程序来将<code>LF</code>转换为各种打字机所需要的<code>EOL</code>，这个方案非常完美，当然除了<code>LF</code>稍微奇怪一些。随后一脉相承的<code>Unix</code>和<code>Linux</code>们都继承了这个选择，于是你在这些操作系统上可以发现每一行的结尾是一个<code>LF</code>，即<code>\n(或0x0A)</code>。</p></li><li><p>Mac: 系统的选择就更加复杂一些。Apple在设计Mac OS时，他们采用了一个最容易理解的选择：<code>CR</code>，即<code>\r</code>(或<code>0x0D</code>)。但这只维持到Mac OS 9，后一个版本的Mac OSX基于Mach-BSD内核，所以此后版本的Mac OSX在每行的结尾存储了与Linux一样的<code>LF</code>，即<code>\n</code>(或<code>0x0A</code>)。</p></li><li><p>还有很多其它的操作系统采用更加不同的方案，这也导致了混乱的产生，</p><p>因为Linux和Mac OSX上使用的是<code>LF</code>，而Windows上使用的是<code>CRLF</code>，那么Linux和Mac OSX上创建的文件在Windows上打开时，由于每一行的结尾只有一个<code>LF</code>，但Windows只认识<code>CRLF</code>，所以便不会有逻辑上的换行处理，故所有的文字被挤到了一行。<br>反过来，如果Windows上的文件在Linux和Mac OSX上打开时，仅需<code>LF</code>便可换行，那么每一行的结尾便多了一个<code>CR</code>，对应的ASCII码为<code>^M</code>。</p></li><li><p>而git的安装向导会特意有一个这样的提醒页面也出于此，因为一个项目可能有多个开发者，每个开发者可能使用的是不同的系统，那么开发者checkout代码时，如果不做换行符的转换，有可能就会出现只有一行或者行尾多了<code>^M</code>的情况。当然，如果你有一个可以识别多种<code>EOL</code>的现代文本编辑器，那么不做转换也无妨(notepad不行)。</p></li></ul></blockquote><h2 id="4-编程语言中的回车换行">4. 编程语言中的回车换行</h2><ul><li>C语言，C系语言</li></ul><p>为了避免在这些不同的实现中挣扎，高级语言给我们带来了福音，它们各自使用了<a href="http://en.wikipedia.org/wiki/Newline#In_programming_languages">统一</a>的方式来处理<code>EOL</code>。在C语言中，你一定知道在字符串中如果要增加一个换行符的话，直接用<code>\n</code>即可，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This is the first line! \nThis is a new line!&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面的输出将是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is the first line!</span><br><span class="line">This is a new line!</span><br></pre></td></tr></table></figure><p>为什么C语言选择了<code>\n</code>而不是<code>\r</code>？这绝非偶然。熟悉C语言历史的朋友可能知道当初C语言是Dennis Ritchie为开发Unix而设计，所以它沿用了Unix上<code>EOL</code>的惯例便很容易理解了。而我们知道Unix使用的<code>LF</code>的ASCII码为<code>0x0A</code>，转义符为<code>\n</code>，因此C语言中也使用<code>\n</code>作为换行。</p><h2 id="Text-Mode-VS-Binary-Mode">Text Mode VS Binary Mode</h2><ul><li>该部分内容转载于：<a href="https://feihu.me/blog/2014/end-of-line/">知无涯之回车换行的故事 (feihu.me)</a></li></ul><p>但是，千万别简单的认为上面的<code>\n</code>最终写到文件中就一定是其ASCII码<code>0x0A</code>，或者文件中的<code>0x0A</code>被读到内存中就是其转义符<code>\n</code>。这取决于你打开文件的方式。在C语言中，在对文件进行读取操作之前，都需要先打开文件，可以使用下面的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure><p>注意看第二个参数<code>mode</code>，它是一个字符指针，通常可以为读®，写(w)，追加(a)或者读写(r+, w+, a+)，仅指定这些参数时，文件将被当成是文本文件来操作，即<code>Text Mode</code>，而如果在这些参数之外再指定一个额外的<code>b</code>时，文件便会被当成是二进制文件，即<code>Binary Mode</code>。这两种模式的区别在哪里呢？这里稍稍有些复杂，因为它们在不同的平台上表现不同。</p><h3 id="Windows平台">Windows平台</h3><p>对于Windows平台，因为其使用<code>CRLF</code>来表示<code>EOL</code>，故对于<code>Text Mode</code>需要做一定的转换才能够与C语言保持一致。接下来的两个图可以给出最为直观的描述。</p><p>先看二者对于读操作的区别：</p><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/2023/08/20230810-184939.png" alt="读操作"></p><p><code>Text Mode</code>下，C语言会尝试去“理解”这些回车与换行，它会知道<code>LF</code>和<code>CRLF</code>都可能是<code>EOL</code>，所以不管文件中是<code>LF</code>还是<code>CRLF</code>，被读进内存时都会变成<code>LF</code>。而<code>Binary Mode</code>下，C语言不会做任何的“理解”，所以这些字符在文件中什么样，读到内存中依然那样。</p><p>接下来是写操作的区别：</p><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/2023/08/20230810-184939.png" alt="写操作"></p><p><code>Text Mode</code>下，内存中的每一个<code>LF</code>写入文件中时都会变为<code>CRLF</code>，当然，如果不幸内存中为<code>CRLF</code>，以此种模式写入到文件中时就会变成<code>CRCRLF</code>（<strong>注意</strong>：这里不是<code>CRLF</code>。原因我想大概是如果你认为内存中的数据是文本，那么它一定是以<code>LF</code>作为<code>EOL</code>，<code>CR</code>也一定是你有意而为之，是个有意义的字符，所以它并不会处理。）。而<code>Binary Mode</code>下，内存中的内容会被原封不动的写到文件中。</p><p>所以为了保证一致性，一定需要注意配套使用读和写，即<strong>读和写采用同一种模式打开文件</strong>。</p><h3 id="Linux和Mac-OSX平台">Linux和Mac OSX平台</h3><p>因为Linux和Mac OSX平台与C语言对待<code>EOL</code>的方式完全一致，所以<code>Text Mode</code>和<code>Binary Mode</code>在这些平台下没有任何区别，可以参考<code>fopen</code>的<a href="http://man7.org/linux/man-pages/man3/fopen.3.html">man page</a>。实际上，所有遵循POSIX的平台都忽略了<code>b</code>这个参数。</p><p>虽说在这些平台上处理<code>EOL</code>非常简单，但是如果你的程序需要移植到其它非POSIX平台上时，请务必正确对待<code>b</code>参数。</p><h2 id="POSIX平台-介绍">POSIX平台 介绍</h2><p>因为Linux和Mac OSX平台与C语言对待<code>EOL</code>的方式完全一致，所以<code>Text Mode</code>和<code>Binary Mode</code>在这些平台下没有任何区别，可以参考<code>fopen</code>的<a href="http://man7.org/linux/man-pages/man3/fopen.3.html">man page</a>。实际上，所有遵循POSIX的平台都忽略了<code>b</code>这个参数。</p><ul><li><p>POSIX：可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ）</p></li><li><p>历史：</p><blockquote><p>974年，贝尔实验室正式对外发布Unix。因为涉及到反垄断等各种原因，加上早期的Unix不够完善，于是贝尔实验室以慷慨的条件向学校提供源代码，所以Unix在大专院校里获得了很多支持并得以持续发展。</p><p>于是出现了好些独立开发的与Unix基本兼容但又不完全兼容的OS，通称Unix-like OS.包括：</p><ol><li>美国加州大学伯克利分校的Unix4.xBSD(Berkeley Software Distribution)。</li><li>贝尔实验室发布的自己的版本，称为System V Unix。</li><li>其他厂商的版本，比如Sun Microsystems的Solaris系统,则是从这些原始的BSD和System V版本中衍生而来。</li></ol><p>20世纪80年代中期，Unix厂商试图通过加入新的、往往不兼容的特性来使它们的程序与众不同。局面非常混乱，麻烦也就随之而来了。</p><p>为了提高兼容性和应用程序的可移植性，阻止这种趋势， IEEE(电气和电子工程师协会)开始努力标准化Unix的开发，后来由 Richard Stallman命名为“Posix”。</p></blockquote></li></ul><p>这套标准涵盖了很多方面，比如Unix系统调用的C语言接口、shell程序和工具、线程及网络编程。</p><ul><li><p>支持POSIX</p><blockquote><p>Unix和Linux</p><p>苹果的操作系统也是Unix-based的</p><p>Windows从WinNT开始就有兼容POSIX的考虑。这是因为当年在要求严格的领域，Unix地位比Windows高。为了把Unix用户拉到Windows阵营，被迫支持POSIX。</p><p>现在Win10对 Linux/POSIX 支持好，则是因为Linux已经统治了廉价服务器市场。为了提高Windows的竞争力搞的。</p></blockquote></li></ul><h2 id="参考">参考</h2><ol><li><a href="https://zh.wikipedia.org/zh-sg/%E5%9B%9E%E8%BB%8A%E9%8D%B5">回车键 - 维基百科，自由的百科全书 (wikipedia.org)</a></li><li><a href="https://en.wikipedia.org/wiki/Newline#History">Newline - Wikipedia</a></li><li><a href="https://www.racecoder.com/archives/383/">回车与换行的一些历史 - 这破站 (racecoder.com)</a></li><li><a href="https://feihu.me/blog/2014/end-of-line/">知无涯之回车换行的故事 (feihu.me)</a></li><li><a href="https://zhuanlan.zhihu.com/p/392588996">posix是什么都不知道，还好意思说你懂Linux？ - 知乎 (zhihu.com)</a></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回车换行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell函数返回值详解</title>
      <link href="/posts/20230809143243-c8a1efbf.html"/>
      <url>/posts/20230809143243-c8a1efbf.html</url>
      
        <content type="html"><![CDATA[<h1>Shell函数返回值详解</h1><p>shell脚本中，执行函数</p><p>通常来说函数返回值有两类</p><h2 id="1-函数执行状态码">1. 函数执行状态码</h2><p>我更愿意称之为函数执行状态码</p><p>标识函数是否执行成功，返回值只能是整数 ，在0-255之间，0表示成功，其他值表示失败</p><blockquote><ul><li><p>函数内，显示使用return 语句，指定 函数返回值，（0-255）</p></li><li><p>不显示使用return 语句，会将最后一条命令运行结果状态作为返回值</p></li><li><p>获取该状态码，需要在函数执行后，<strong>立即</strong>从 $? 变量获取  ，因为该变量只显示最后命令的退出状态</p></li><li><table><thead><tr><th>$?</th><th>仅显示最后命令的退出状态，0表示没有错误，其他表示有错误；</th></tr></thead></table></li></ul></blockquote><h3 id="举例">举例</h3><ol><li>return  整数 0-255，获取为正常状态码</li><li>return 字符串，报错，<a href="http://test.sh">test.sh</a>: line 11: return: xyz: numeric argument required</li><li>return 整数大于255，返回值 为 整数 取模256 ，如下例 64789 % 256 = 21</li><li>不显示使用return 语句，则函数内最后一条命令的执行结果，0为正常，其他错误</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo0</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> 64789</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo1</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo2</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">&quot;xyz&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fooa</span></span>() &#123;</span><br><span class="line">    <span class="built_in">ls</span> *.sh</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foob</span></span>() &#123;</span><br><span class="line">    <span class="built_in">ls</span> *.ksh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo0</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;foo0 return $?\n..&quot;</span></span><br><span class="line">foo1</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;foo1 return $?\n..&quot;</span></span><br><span class="line">foo2</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;foo2 return $?\n..&quot;</span></span><br><span class="line">fooa</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;fooa return $?\n..&quot;</span></span><br><span class="line">foob</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;foob return $?\n..&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>代码执行结果</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">foo0 <span class="built_in">return</span> 21</span><br><span class="line">..</span><br><span class="line">foo1 <span class="built_in">return</span> 1</span><br><span class="line">..</span><br><span class="line">test.sh: line 11: <span class="built_in">return</span>: xyz: numeric argument required</span><br><span class="line">foo2 <span class="built_in">return</span> 255</span><br><span class="line">..</span><br><span class="line">excutep.sh  test.sh</span><br><span class="line">fooa <span class="built_in">return</span> 0</span><br><span class="line">..</span><br><span class="line"><span class="built_in">ls</span>: cannot access *.ksh: No such file or directory</span><br><span class="line">foob <span class="built_in">return</span> 2</span><br><span class="line">..</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-用户自定义的函数执行返回结果">2. 用户自定义的函数执行返回结果</h2><p>也有两种方式</p><h3 id="1-函数内-给全局变量-赋值">1. 函数内 给全局变量 赋值</h3><blockquote><ol><li>函数外首先定义全局变量</li><li>函数内修改全局变量</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">cc=<span class="string">&quot;aa&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fooc</span></span>() &#123;</span><br><span class="line">    cc=<span class="string">&quot;bb&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$cc</span>&quot;</span></span><br><span class="line">fooc</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;fooc return $? \n  cc=<span class="variable">$cc</span>   \n..&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>函数执行结果</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">..</span><br><span class="line">aa</span><br><span class="line">fooc return 0</span><br><span class="line">  cc=bb   </span><br><span class="line">..</span><br></pre></td></tr></table></figure><h3 id="2-执行函数的shell，继承函数内部的打印输出">2. 执行函数的shell，继承函数内部的打印输出</h3><blockquote><ol><li>函数内部 包括打印语句<br>比如 echo 语句，不止echo，还包括，head、cat等等</li><li>执行函数并赋值给一个变量 ，注意 dd=<code>food</code>，函数名使用`` 包裹表示执行函数<ul><li>而且通过下述例子可以看出，状态码是函数体内部返回的 状态码 5，也即该赋值操作，没改变变量$?</li><li>函数内部有多处打印输出，则通过该种方法赋值时，赋值为一个字符串<br>==会把多行输出都合并到一个字符串中，并且以一个空格做分割==<br>( 这里一个测试时很奇怪的点<br>原因是，以<code>echo $dd</code> 打印，结果以空格分割<br>和以<code>echo &quot;$dd&quot;</code> 打印结果以换行分割)</li></ul></li><li>执行函数若不进行赋值操作，则函数内部的打印输出也会直接被继承到调用函数shell 的打印输出 顺序中</li></ol></blockquote><h3 id="举例-2">举例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">food</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;11&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;22 222&quot;</span></span><br><span class="line">    <span class="built_in">head</span> -1 test.sh</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;33&quot;</span></span><br><span class="line">    <span class="built_in">return</span> 5</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;directly print:&quot;</span>  `food`</span><br><span class="line"><span class="built_in">dd</span>=`food`</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;food return $? &quot;</span></span><br><span class="line"><span class="built_in">echo</span>  <span class="variable">$dd</span> <span class="string">&quot;start:<span class="variable">$&#123;dd&#125;</span>end&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;****************&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;if dd is string, print the length of dd: <span class="variable">$&#123;#dd&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;if dd is array,print the length of array: <span class="variable">$&#123;#dd[@]&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fooe</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;11&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;22 222&quot;</span></span><br><span class="line">    <span class="built_in">head</span> -1 return_fuc_test.sh</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;33&quot;</span></span><br><span class="line">    <span class="built_in">return</span> 5</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 无赋值操作 则函数内部打印，会直接打印出来</span></span><br><span class="line">fooe</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;fooe return $? &quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>函数执行结果</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">directly print: 11 22 222 #!/bin/bash 33</span><br><span class="line">food return 5 </span><br><span class="line">11 22 222 #!/bin/bash 33 start:11</span><br><span class="line">22 222</span><br><span class="line">#!/bin/bash</span><br><span class="line">33end</span><br><span class="line">****************</span><br><span class="line">if dd is string, print the length of dd: 24</span><br><span class="line">if dd is array,print the length of array: 1</span><br><span class="line"># 按数组来看，查询数组长度为1，所以函数返回值是一个字符串</span><br><span class="line"></span><br><span class="line">11</span><br><span class="line">22 222</span><br><span class="line">#!/bin/bash</span><br><span class="line">33</span><br><span class="line">fooe return 5 </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ol><li>函数执行状态码，一般是用来判断 函数执行结果状态</li><li>第二种方式，获取函数返回值，如同一般编程中函数返回值使用</li></ol><h1>参考</h1><ol><li><a href="https://blog.51cto.com/u_13800449/3049036">linux shell返回值方式及示例_51CTO博客_shell脚本返回值</a></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell函数返回值 </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReadyToRead</title>
      <link href="/posts/20230626153850-8f8e2f5b.html"/>
      <url>/posts/20230626153850-8f8e2f5b.html</url>
      
        <content type="html"><![CDATA[<h1>articles</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/79202151">BM25算法, Best Matching - 知乎专栏</a></li><li><a href="https://zhuanlan.zhihu.com/p/31009310">BM25F模型 - 知乎专栏</a></li><li><a href="https://lumingdong.cn/go/4q3yru">推荐系统算法调研. 蘑菇先生学习记</a><a href="https://lumingdong.cn/recommendation-algorithm-based-on-matrix-decomposition.html#ref-footnote-3">↩</a></li><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LearningToRank-排序学习</title>
      <link href="/posts/20230626151728-e7cc9d05.html"/>
      <url>/posts/20230626151728-e7cc9d05.html</url>
      
        <content type="html"><![CDATA[<h1>传统排序方法</h1><ol><li><strong>传统的排序方法通过构造相关度函数，按照相关度进行排序</strong>。<br>很难融合多种因数，比如向量空间模型以tf*idf作为权重构建相关度函数，就很难利用其他信息了，</li><li>并且如果模型中参数比较多，也会使得调参非常困难，而且很可能会出现过拟合现象。</li></ol><p>Ranking模型可以粗略分为基于相关度和机遇重要性进行排序。</p><p>基于相关度的模型，通常利用query和doc之间的词共现特性（如布尔模型）、VSM（如TFIDF、LSI等）、概率排序思想（BM25、LMIR）等。</p><p>基于重要性的模型，利用的是doc本身的重要性，如pageRank、TructRank等。</p><h1>Learning To Rank</h1><p>LTR（Learning to rank）是一种==监督学习==（SupervisedLearning）的==排序方法==，已经被广泛应用到推荐与搜索等领域。</p><h2 id="LTR采用机器学习">LTR采用机器学习</h2><p>很好地解决了这一问题。机器学习方法很容易融合多种特征，而且有成熟深厚的理论基础，并有一套成熟理论解决稀疏、过拟合等问题。</p><p>排序学习方法分为PointWise、PairWise、ListWise三种不同的方式，参考《A Short Introduction to Learning to Rank》</p><p>三种方法并不是特定的算法，而是排序学习模型的设计思路，主要区别体现在损失函数（Loss Function）、以及相应的标签标注方式和优化方法的不同。</p><p>LTR中单文档方法是将训练集里每一个文档当做一个训练实例,文档对方法是将同一个查询的搜索结果里任意两个文档对作为一个训练实例,文档列方法是将一个查询里的所有搜索结果列表作为一个训练实例.</p><ul><li><p>设q  为query，D(d_i,…… d_n) 为返回的文档对，如何排序</p><blockquote><ol><li>Point-Wise:       <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><msub><mi>d</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>Y</mi><mrow><mi>q</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">F(d_i) = Y_{qi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>     根据相关度Y 对D排序</li><li>Pair-Wise :      <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>d</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>d</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(q,(d_i,d_j))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span>     ；  二分类，确定d_i,和d_j的顺序关系</li><li>List-Wise:       <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>Y</mi><mi>D</mi></msub></mrow><annotation encoding="application/x-tex">F(q,D) = Y_{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>    ；(q,D)作为输入进行分类或者回归</li></ol></blockquote></li></ul><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/2023/08/20230816-105350" alt="img"></p><h1>PointWise 单点法</h1><p>Pointwise方法是这三种排序学习方法中最简单点一种，它是思想是直接将排序问题转换成了分类或者回归问题</p><p>假如已有排序学习的训练数据集，每个query对应了多个不同的多doc，并且每个doc与相应query的相关度已知道，那么Pointwise方法在训练时会把每个单独的doc本身看作X ，把与query的相关度看作Y ，然后利用分类或者回归模型进行训练，最后依据利用训练好的模型对不同doc的打分进行排序</p><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/2023/08/20230816-104448.jpg" alt="p"></p><blockquote><p>0/1变量 时，为PosintWise二分类</p><p>为离散变量时，为PointWise多分类</p><p>为连续变量时，为PointWise回归</p></blockquote><h2 id="PointWise-方法存在的问题：">PointWise 方法存在的问题：</h2><p>PointWise 方法通过优化损失函数求解最优的参数，可以看到 PointWise 方法非常简单，工程上也易实现，但是 PointWise 也存在很多问题：</p><ol><li>PointWise ==只考虑单个文档同 query 的相关性==，没有考虑文档间的关系，即假设各个doc之间是相互独立的，这种假设是不成立的。<br>然而排序追求的是排序结果，并不要求精确打分，只要有相对打分即可；</li><li>通过分类只是把不同的文档做了一个简单的区分，同一个类别里的文档则无法深入区别，虽然我们可以根据预测的概率来区别，但实际上，==这个概率只是准确度概率，并不是真正的排序靠前的预测概率==；</li><li>PointWise 方法并没有考虑同一个 query 对应的文档间的内部依赖性。<ul><li>一方面，导致输入空间内的样本不是 IID 的，违反了 ML 的基本假设，</li><li>另一方面，没有充分利用这种样本间的结构性。</li><li>其次，当不同 query 对应不同数量的文档时，==整体 loss 将容易被对应文档数量大的 query 组所支配==，应该每组 query 都是等价的才合理。</li></ul></li><li>很多时候，排序结果的 Top N 条的顺序重要性远比剩下全部顺序重要性要高，==因为损失函数没有相对排序位置信息，这样会使损失函数可能无意的过多强调那些不重要的 docs，==即那些排序在后面对用户体验影响小的 doc，所以对于位置靠前但是排序错误的文档应该加大惩罚。</li></ol><h2 id="数据输入和输出形式：">数据输入和输出形式：</h2><p>Pointwise方法是通过近似为回归问题解决排序问题，</p><ol><li><p>输入的单条样本为得分-文档，将每个查询-文档对的相关性得分作为实数分数或者序数分数，使得单个查询-文档对作为样本点(Pointwise的由来)，训练排序模型。</p></li><li><p>预测时候对于指定输入，给出查询-文档对的相关性得分。</p></li></ol><ul><li>代表算法：</li></ul><p>基于神经网络的排序算法 RankProp、基于感知机的在线排序算法 Prank(Perception Rank)/OAP-BPM 和基于 SVM 的排序算法。</p><p>推荐中使用较多的 Pointwise 方法是 LR、GBDT、SVM、FM 以及结合 DNN 的各种排序算法。</p><h1>PairWise 配对法</h1><p>配对法的基本思路是对样本进行两两比较，构建偏序文档对，从比较中学习排序，因为对于一个查询关键字来说，最重要的其实不是针对某一个文档的相关性是否估计得准确，而是要能够正确估计一组文档之间的 “相对关系”。</p><p>PairWise方法的思想是将同一个query下多个不同doc之间进行两两组对，然后将&lt;doc, doc&gt;pair doc作为模型输入进行一个二分类的任务学习。PairWise首先将doc进行两两组对，然后比较doc与query的相关度大小，如果第一个doc的相关度大于第二个doc，则这对doc的标签设置为1否则为0。常用模型包括有RankNet、LambdaRank、LambdaMart等。</p><p>因此，Pairwise 的训练集样本从每一个 “关键字文档对” 变成了 “关键字文档文档配对”。也就是说，每一个数据样本其实是一个比较关系，当前一个文档比后一个文档相关排序更靠前的话，就是正例，否则便是负例，如下图。试想，有三个文档：A、B 和 C。完美的排序是 “B&gt;C&gt;A”。我们希望通过学习两两关系 “B&gt;C”、“B&gt;A” 和 “C&gt;A” 来重构 “B&gt;C&gt;A”。</p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/2023/08/20230816-104719.jpg" alt="v2-3f03a6e52527d5992482cc3e3f075650_r" style="zoom: 50%;" /><p>这里面有几个非常关键的假设。换句话说，标注是一个困难的事情，难点在于：是否存能得到完美关系？是否能重构完美排序？</p><h2 id="Pairwise-方法存在的问题：">Pairwise 方法存在的问题：</h2><p>Pairwise 方法通过考虑两两文档之间的相关对顺序来进行排序，相比 PointWise 方法有明显改善。但 Pairwise 方法仍有如下问题：</p><ol><li>使用的==是两文档之间相关度的损失函数，而它和真正衡量排序效果的指标之间存在很大不同==，甚至可能是负相关的，如可能出现 Pairwise Loss 越来越低，但 NDCG 分数也越来越低的现象。</li><li>==只考虑了两个文档的先后顺序，且没有考虑文档在搜索列表中出现的位置==，导致最终排序效果并不理想。</li><li>==不同的查询，其相关文档数量差异很大==，转换为文档对之后，有的查询可能有几百对文档，有的可能只有几十个，这样不加均一化地在一起学习，模型会优先考虑文档对数量多的查询，减少这些查询的 loss，最终对机器学习的效果评价造成困难。</li><li>Pairwise 方法的训练样例是偏序文档对，它将对文档的排序转化为对不同文档与查询相关性大小关系的预测；因此，如果因某个文档相关性被预测错误，或文档对的两个文档相关性均被预测错误，则会影响与之关联的其它文档，进而引起连锁反应并影响最终排序结果。</li></ol><h2 id="数据输入和输出形式：-2">数据输入和输出形式：</h2><p>Pairwise方法是通过近似为分类问题解决排序问题，输入的单条样本为标签-文档对。</p><ol><li>对于一次查询的多个结果文档，组合任意两个文档形成文档对作为输入样本。即学习一个二分类器，对输入的一对文档对AB（Pairwise的由来），根据A相关性是否比B好，二分类器给出分类标签1或0。</li><li>对所有文档对进行分类，就可以得到一组偏序关系，从而构造文档全集的排序关系。</li><li>该类方法的原理是对给定的文档全集S，降低排序中的逆序文档对的个数来降低排序错误，从而达到优化排序结果的目的。</li></ol><ul><li><strong>代表算法：</strong></li></ul><p>基于 SVM 的 Ranking SVM 算法、基于神经网络的 RankNet 算法和基于 Boosting 的 RankBoost 算法。</p><h1>ListWise 列表法</h1><p><em><strong>相对于尝试学习每一个样本是否相关或者两个文档的相对比较关系，列表法排序学习的基本思路是尝试直接优化像 NDCG（Normalized Discounted Cumulative Gain）这样的指标，从而能够学习到最佳排序结果。</strong></em></p><blockquote><p>列表法的相关研究有很大一部分来自于微软研究院，这其中著名的作者就有微软亚州院的徐君、李航、刘铁岩等人，以及来自微软西雅图的研究院的著名<strong>排序算法 LambdaMART</strong> 以及 Bing 搜索引擎的主导人克里斯托弗·博格斯（Christopher J.C. Burges）。</p></blockquote><p>列表法排序学习有两种基本思路。</p><ol><li>第一种称为 Measure-specific，就是直接针对 NDCG 这样的指标进行优化。<br>目的简单明了，用什么做衡量标准，就优化什么目标。</li><li>第二种称为 Non-measure specific，则是根据一个已经知道的最优排序，尝试重建这个顺序，然后来衡量这中间的差异。</li></ol><h2 id="Measure-specific">Measure-specific</h2><p>先来看看<em><strong>直接优化排序指标</strong></em>的难点和核心在什么地方。</p><ul><li>难点在于，希望能够优化 NDCG 指标这样的 “理想” 很美好，但是现实却很残酷。<br>NDCG、MAP 以及 AUC 这类排序标准，都是在数学的形式上的 “非连续”（Non-Continuous）和 “非可微分”（Non-Differentiable）。<br>而绝大多数的优化算法都是基于 “连续”（Continuous）和 “可微分”（Differentiable）函数的。因此，直接优化难度比较大。</li></ul><p>三种思路</p><ul><li><p>第一种方法是，既然直接优化有难度，那就找一个近似 NDCG 的另外一种指标。而这种替代的指标是 “连续” 和 “可微分” 的 。只要我们建立这个替代指标和 NDCG 之间的近似关系，那么就能够通过优化这个替代指标达到逼近优化 NDCG 的目的。这类的代表性算法的有 SoftRank 和 AppRank。</p></li><li><p>第二种方法是，尝试从数学的形式上写出一个 NDCG 等指标的 “边界”（Bound），然后优化这个边界。比如，如果推导出一个上界，那就可以通过最小化这个上界来优化 NDCG。这类的代表性算法有 SVM-MAP 和 SVM-NDCG。</p></li><li><p>第三种方法则是，希望从优化算法上下手，看是否能够设计出复杂的优化算法来达到优化 NDCG 等指标的目的。对于这类算法来说，算法要求的目标函数可以是 “非连续” 和 “非可微分” 的。这类的代表性算法有 AdaRank 和 RankGP</p></li></ul><h2 id="Non-measure-specific">Non-measure specific</h2><p>这种思路的主要假设是，已经知道了针对某个搜索关键字的完美排序，那么怎么通过学习算法来逼近这个完美排序。我们希望缩小预测排序和完美排序之间的差距。值得注意的是，在这种思路的讨论中，优化 NDCG 等排序的指标并不是主要目的。这里面的代表有 ListNet 和 ListMLE。</p><ul><li><p>Listwise 方法存在的问题：</p><blockquote><p>列表法相较单点法和配对法针对排序问题的模型设计更加自然，解决了排序应该基于 query 和 position 问题。</p><p>但列表法也存在一些问题：一些算法需要基于排列来计算 loss，从而使得训练复杂度较高，如 ListNet 和 BoltzRank。此外，位置信息并没有在 loss 中得到充分利用，可以考虑在 ListNet 和 ListMLE 的 loss 中引入位置折扣因子</p></blockquote></li><li><p>基于列的学习排序(Listwise Approach)是将qid=10对应的所有查询文档作为一个实例进行训练,即一个查询及其对应的所有搜索结果评分作为一个实例进行训练;训练得到一个最后评分函数F后,test测试集中一个新的查询,函数F对每一个文档进行打分,之后按照得分顺序由高到低排序即是对应搜索的结果.</p></li></ul><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/2023/08/20230816-104826.jpg" alt="v2-0bc0cd36af20a0d781b49755368332ca_r"></p><ul><li>代表算法：</li></ul><p>基于 Measure-specific 的 SoftRank、SVM-MAP、SoftRank、LambdaRank、LambdaMART，基于 Non-measure specific 的 ListNet、ListMLE、BoltzRank。</p><p>推荐中使用较多的 Listwise 方法是 LambdaMART。</p><h1>评价</h1><p>ListWise方法相比于pariwise和pointwise往往更加直接，它专注于自己的目标和任务，直接对文档排序结果进行优化，因此往往效果也是最好的。</p><table><thead><tr><th></th><th>Point wise</th><th>pairwise</th><th>list wise</th></tr></thead><tbody><tr><td>思想</td><td>Pointwise排序是将训练集中的每个item看作一个样本获取rank函数，主要解决方法是把分类问题转换为单个item的分类或回归问题。</td><td>Pairwise排序是将同一个查询中两个不同的item作为一个样本，主要思想是把rank问题转换为二值分类问题</td><td>Listwise排序是将整个item序列看作一个样本，通过直接优化信息检索的评价方法和定义损失函数两种方法实现。</td></tr><tr><td>算法</td><td>1、基于回归的算法；<br />2、基于分类的算法；<br />3、基于有序回归的算法</td><td>基于二分类的算法</td><td>直接基于评价指标的算法<br />非直接基于评价指标的算法</td></tr><tr><td>缺点</td><td>ranking 追求的是排序结果，并不要求精确打分，只要有相对打分即可。<br />pointwise 类方法并没有考虑同一个 query 对应的 docs 间的内部依赖性。一方面，导致输入空间内的样本不是 IID 的，违反了 ML 的基本假设，另一方面，没有充分利用这种样本间的结构性。<br />其次，当不同 query 对应不同数量的 docs 时，整体 loss 将会被对应 docs 数量大的 query 组所支配，前面说过应该每组 query 都是等价的。损失函数也没有 model 到预测排序中的位置信息。因此，损失函数可能无意的过多强调那些不重要的 docs，即那些排序在后面对用户体验影响小的 doc。</td><td>1、如果人工标注包含多有序类别，那么转化成 pairwise preference 时必定会损失掉一些更细粒度的相关度标注信息。<br />2、doc pair 的数量将是 doc 数量的二次，从而 pointwise 类方法就存在的 query 间 doc 数量的不平衡性将在 pairwise 类方法中进一步放大。<br />3、pairwise 类方法相对 pointwise 类方法对噪声标注更敏感，即一个错误标注会引起多个 doc pair 标注错误。<br />4、pairwise 类方法仅考虑了 doc pair 的相对位置，损失函数还是没有 model 到预测排序中的位置信息。<br />5、pairwise 类方法也没有考虑同一个 query 对应的 doc pair 间的内部依赖性，即输入空间内的样本并不是 IID 的，违反了 ML 的基本假设，并且也没有充分利用这种样本间的结构性。</td><td>listwise 类相较 pointwise、pairwise 对 ranking 的 model 更自然，解决了 ranking 应该基于 query 和 position 问题。<br />listwise 类存在的主要缺陷是：<br />一些 ranking 算法需要基于排列来计算 loss，从而使得训练复杂度较高，如 ListNet和 BoltzRank。<br />此外，位置信息并没有在 loss 中得到充分利用，可以考虑在 ListNet 和 ListMLE 的 loss 中引入位置折扣因子。</td></tr><tr><td>优点</td><td>1、输入空间中样本是单个 doc（和对应 query）构成的特征向量；<br />2、输出空间中样本是单个 doc（和对应 query）的相关度；<br />3、假设空间中样本是打分函数；损失函数评估单个 doc 的预测得分和真实得分之间差异。</td><td>输入空间中样本是（同一 query 对应的）两个 doc（和对应 query）构成的两个特征向量；<br />输出空间中样本是 pairwise preference；假设空间中样本是二变量函数；损失函数评估 doc pair 的预测 preference 和真实 preference 之间差异。</td><td>输入空间中样本是（同一 query 对应的）所有 doc（与对应的 query）构成的多个特征向量（列表）；<br />输出空间中样本是这些 doc（和对应 query）的相关度排序列表或者排列；<br />假设空间中样本是多变量函数，对于 docs 得到其排列，实践中，通常是一个打分函数，根据打分函数对所有 docs 的打分进行排序得到 docs 相关度的排列；损失函数分成两类，一类是直接和评价指标相关的，还有一类不是直接相关的。</td></tr></tbody></table><h1>参考</h1><ul><li>转载</li></ul><ol><li><a href="https://zhuanlan.zhihu.com/p/111636490">Learning to Rank： pointwise 、 pairwise 、 listwise</a></li><li><a href="https://everdark.github.io/k9/notebooks/ml/learning_to_rank/learning_to_rank.html">Introduction to Learning-to-Rank</a></li><li><a href="https://www.baidu.com/link?url=eTmEKqnuaVZEADp449zPJ2ape2WhtLcb15Z2qYhgDak1eqs5-YV1sg5s4PQ6aRoLJK39WdUIjvejdoh-A9Wps10JQJOHENZCIHfr-ooIK8i&amp;wd=&amp;eqid=dd34397e0016c6be00000003649aba54">【推荐】<em>pairwise</em>、<em>pointwise</em> 、 <em>listwise</em>算法是什么?怎么…</a></li><li><a href="https://zhuanlan.zhihu.com/p/450959441">排序学习-2.排序学习方法分类 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/337478373">推荐- Point wise、pairwise及list wise的比较 - 知乎 (zhihu.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 排序学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LTR </tag>
            
            <tag> 排序学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora代码块-添加折叠展开按钮</title>
      <link href="/posts/20230613222744-8b05256b.html"/>
      <url>/posts/20230613222744-8b05256b.html</url>
      
        <content type="html"><![CDATA[<p>Typora 是一款由 Abner Lee 开发的<a href="https://baike.baidu.com/item/%E8%BD%BB%E9%87%8F%E7%BA%A7/10002835?fromModule=lemma_inlink">轻量级</a> Markdown 编辑器，与其他 Markdown 编辑器不同的是，Typora 没有采用<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3969?fromModule=lemma_inlink">源代码</a>和预览双栏显示的方式，而是采用所见即所得的编辑方式，实现了即时预览的功能，但也可切换至源代码编辑模式。</p><p>一个遗憾是不支持，代码块的折叠，当代码块中代码行数过多，会显得臃肿</p><h1>代码块添加折叠按钮</h1><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230613222824.png" alt="image-20230613220158516"></p><p>Typora实际就是一个浏览器</p><p>通过修改Typora安装目录如下 的  frame.js文件，来实现这个功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\NotesRead\Typora\resources\appsrc\window\frame.js</span><br></pre></td></tr></table></figure><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230613222824.png" alt="image-20230613215619674"></p><ul><li>在文件  frame.js的末尾添加如下代码</li></ul><h2 id="1-在单个代码块添加代码收缩按钮">1. 在单个代码块添加代码收缩按钮</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加代码收缩功能</span></span><br><span class="line">content.<span class="title function_">addEventListener</span>(<span class="string">&quot;mouseover&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">codeDivs.<span class="title function_">forEach</span>(<span class="function">(<span class="params">div, index</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (div.<span class="property">firstChild</span>.<span class="property">nodeName</span> != <span class="string">&quot;BUTTON&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> button = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">button.<span class="property">className</span> = <span class="string">&quot;contract-code-button&quot;</span>;</span><br><span class="line">button.<span class="property">innerText</span> = <span class="string">&quot;代码收缩&quot;</span>;</span><br><span class="line">button.<span class="property">onclick</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (div.<span class="property">style</span>.<span class="property">height</span> != <span class="string">&quot;2.9em&quot;</span>) &#123;</span><br><span class="line">button.<span class="property">innerText</span> = <span class="string">&quot;代码展开&quot;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&quot;2.9em&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">button.<span class="property">innerText</span> = <span class="string">&quot;代码收缩&quot;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&quot;inherit&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">div.<span class="title function_">insertBefore</span>(button, div.<span class="property">firstChild</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-添加收缩文件全部代码块按钮">2.添加收缩文件全部代码块按钮</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加收缩全部按钮</span></span><br><span class="line"><span class="keyword">var</span> isAdd = <span class="literal">false</span>;</span><br><span class="line">content.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isAdd) &#123;</span><br><span class="line"><span class="keyword">var</span> footer = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;footer&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全部收缩按钮</span></span><br><span class="line"><span class="keyword">var</span> contractButton = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">contractButton.<span class="property">innerText</span> = <span class="string">&quot;全部收缩&quot;</span>;</span><br><span class="line">contractButton.<span class="property">name</span> = <span class="string">&quot;contarctAllButton&quot;</span>;</span><br><span class="line">contractButton.<span class="property">className</span> = <span class="string">&quot;contract-all-button&quot;</span>;</span><br><span class="line">contractButton.<span class="property">onclick</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">var</span> buttons = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;contract-code-button&quot;</span>);</span><br><span class="line">buttons.<span class="title function_">forEach</span>(<span class="function">(<span class="params">button, index</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">var</span> div = button.<span class="property">parentNode</span>;</span><br><span class="line">button.<span class="property">innerText</span> = <span class="string">&quot;代码展开&quot;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&quot;2.9em&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全部展开按钮</span></span><br><span class="line"><span class="keyword">var</span> expandButton = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">expandButton.<span class="property">innerText</span> = <span class="string">&quot;全部展开&quot;</span>;</span><br><span class="line">expandButton.<span class="property">name</span> = <span class="string">&quot;expandAllButton&quot;</span>;</span><br><span class="line">expandButton.<span class="property">className</span> = <span class="string">&quot;expand-all-button&quot;</span>;</span><br><span class="line">expandButton.<span class="property">onclick</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">var</span> buttons = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;contract-code-button&quot;</span>);</span><br><span class="line">buttons.<span class="title function_">forEach</span>(<span class="function">(<span class="params">button, index</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">var</span> div = button.<span class="property">parentNode</span>;</span><br><span class="line">button.<span class="property">innerText</span> = <span class="string">&quot;代码收缩&quot;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&quot;inherit&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">footer.<span class="title function_">append</span>(contractButton);</span><br><span class="line">footer.<span class="title function_">append</span>(expandButton);</span><br><span class="line">isAdd = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h1>实现效果</h1><ol><li><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230625221127.png" alt="image-20230625221126253"><br><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230625221323.png" alt="image-20230625221322980"></p></li><li><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230625221247.png" alt="image-20230625221247195"></p></li></ol><h1>参考</h1><ol><li><a href="https://baike.baidu.com/item/Typora/59397163?fr=aladdin">Typora</a></li><li><a href="https://www.baidu.com/link?url=vi5U5lv00bECq-fkX5mqrhd7uQJ53z1W6CKvh4ZGmMS&amp;wd=&amp;eqid=960a248d0007b0710000000364886a64">Typora官方中文站</a></li><li><a href="https://blog.csdn.net/qq_41259552/article/details/107892376">CSDN-jo尼jo斯达博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
          <category> PC软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown笔记 </tag>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统简述</title>
      <link href="/posts/20230310224218-66919c32.html"/>
      <url>/posts/20230310224218-66919c32.html</url>
      
        <content type="html"><![CDATA[<h1>推荐系统</h1><h2 id="什么是推荐">什么是推荐</h2><blockquote><ul><li>推荐是一种思维方式</li><li><ol><li>作为搜索的延申</li><li>作为广告的土壤</li><li>掌握信息传播主动权</li></ol></li><li>适用场景<ol><li>资源受限的信息过滤</li><li>导向性的信息展现</li><li>目的性的资源分配</li></ol></li><li></li></ul></blockquote><h2 id="解决问题">解决问题</h2><ol><li><p>信息过载</p></li><li><p>挖掘长尾</p><blockquote><ul><li><a href="https://baike.baidu.com/item/%E9%95%BF%E5%B0%BE/389156?fr=aladdin">长尾</a><br>是指那些原来不受到重视的销量小但种类多的产品或服务由于总量巨大，累积起来的总收益超过主流产品的现象。在互联网领域，长尾效应尤为显著。长尾术语也在统计学中被使用，通常应用在财产的分布和词汇。</li><li>帕雷托法则<br>向来被商业界视为铁律，其内涵认为企业界80%的业绩来自20%的产品</li></ul><p>数据、物品价值</p></blockquote></li><li><p>用户体验</p><blockquote><p>提升用户体验；帮助用户发现自己很难发现的兴趣点、商品……</p></blockquote></li></ol><h2 id="推荐系统的技术演进">推荐系统的技术演进</h2><blockquote><ol><li><p>早期论坛的打分系统；hacknews；reddit;</p></li><li><p>早期社交内容</p></li><li><p>早期电商内容</p></li><li><p>单一算法到多算法融合<br>基于内容的算法 ;( 文本相关性, 主题相关性)<br>基于行为的算法 ;( 协同过滤的变种，随机游走等其他行为类算法  )<br>结果融合；人工规则</p></li><li><p>引入机器学习模型</p><blockquote><p>启发式，无明确目标<br>相对静态，反应慢<br>考虑维度较少，个性化程度不足<br>纯手工，改进空间小</p></blockquote><blockquote><p>对齐明确目标，成熟的优化方法<br>时效性灵活，反映可快可慢特征维度丰富，个性化程度细腻<br>理论储备丰富，发展空间大</p></blockquote></li><li><p>深度学习</p><blockquote><ul><li>从浅层模型到深度模型</li><li><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230310224419.png" alt="image-20230309200210231" style="zoom:50%;" /></li></ul></blockquote></li></ol></blockquote><h2 id="推荐系统基本流程">推荐系统基本流程</h2><ol><li><h2 id="召回">召回</h2><blockquote><ul><li>协同过滤</li><li>内容相似召回</li><li>热门召回</li><li>……</li></ul></blockquote></li><li><h2 id="排序">排序</h2><blockquote><ul><li>机器学习</li><li>二分类算法</li><li>深度学习算法</li><li></li></ul></blockquote></li><li><h2 id="调整-重排">调整(重排)</h2><blockquote><ul><li>针对 具体场景</li></ul><hr><ul><li>去重</li><li>过滤，热门补充</li></ul></blockquote></li></ol><h3 id="召回-2">召回</h3><ul><li><p>一般召回路径</p><blockquote><ol><li>i2i</li><li>u2i</li><li>u2i2i</li><li>u2u2i</li><li>u2tag2i<br>泛化性好</li><li>u2***2i<br>基于图的算法</li></ol></blockquote></li></ul><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230516165627.png" alt="image-20230516165625814"><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230310224420.png" alt="image-20230309155810040"></p><h3 id="排序-2">排序</h3><h3 id="调整">调整</h3><h2 id="通用推荐系统技术架构（数据流图）">通用推荐系统技术架构（数据流图）</h2><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230310224422.png" alt="image-20230309161118965"></p><h1>推荐系统的方法</h1><h2 id="Content-Based-基于内容的推荐系统">Content-Based   ; 基于内容的推荐系统</h2><ul><li>最早被使用的推荐算法，效果良好</li><li>给用户推荐之前喜欢的物品，相似的物品</li><li>u2i2i<br>u2tag2i</li></ul><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230310224421.png" alt="image-20230309165128805"></p><h3 id="重点：相似度计算">重点：相似度计算</h3><ol><li>余弦相似度</li><li></li></ol><h3 id="优缺点">优缺点</h3><ul><li><p>优点</p><blockquote><ol><li>不需要其他用户的数据</li><li>能给具备独特口味的用户推荐</li><li>可以推荐最新的、冷门的物品</li><li>容易做推荐结果的解释</li></ol></blockquote></li><li><p>缺点</p><blockquote><ol><li>很难找到能表达物品的“标签”，有时候需要人工打标签</li><li>过于局限于自己的世界，无法挖掘出用户的潜在兴趣</li><li>新用户如果没有行为，没法做推荐  (<em><strong>==冷启动问题==</strong></em>)</li></ol></blockquote></li></ul><h2 id="Collaborative-Filtering-协同过滤">Collaborative-Filtering  ; 协同过滤</h2><ul><li><p>大类，一般也分为两种</p><blockquote><ul><li><blockquote><ol><li>Memory-based CF ; 基于数据统计（记忆）的协同过滤</li><li>Model-based CF ; 基于模型（参数学习）的协同过滤</li></ol></blockquote></li><li><blockquote><ul><li>基于用户的协同过滤<br>u2u2i</li><li>基于物品的协同过滤<br>u2i2i</li></ul><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230310224419.png" alt="image-20230309175315079"></p></blockquote></li></ul></blockquote></li></ul><h3 id="example">example</h3><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230310224422.png" alt="image-20230309171614207"></p><hr><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230310224420.png" alt="image-20230309171709127"></p><h2 id="CF-Content-based-混合推荐系统">CF+Content-based ;  混合推荐系统</h2><h1>推荐系统一般问题</h1><h2 id="冷启动问题">冷启动问题</h2><h1>实战应用考虑方法</h1><h2 id="多路召回融合排序">多路召回融合排序</h2><blockquote><ul><li>一般会使 用多个召回策略，互相弥补不足，效果更好，三个臭皮匠顶个诸葛亮。</li><li>每个策略之间毫不相关，一般可以编写并发多线程同时执行</li><li>问题:怎样将多个召回列表融合成一个有序列表?</li></ul></blockquote><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230310224419.png" alt="image-20230309171938088"></p><blockquote><ul><li><blockquote><p>举例，几种召回策略返回的列表(Item-ID、权重)分别为:</p><p>召回策略x:A0.9，B0.8,C0.7<br>召回策略Y:B0.6，C0.5，D0.4<br>召回策略Z∶C0.3，D0.2，E0.1</p></blockquote></li><li><p>策略:效果依次变好，按照成本进行选择</p></li></ul><p>1、按顺序展示:比如实时&gt;购买数据召回&gt;播放数据召回，则直接展示A、B、C、D、E</p><p>2、平均法:分母为召回策略个数，分子为权重加和，C为(0.7+0.5+0.3)/3，B为(0.8+0.6)/3，</p><p>3、加权平均:比如三种策略自己指定权重为0…4、0.3、0.2，则B的权重为(0.4<em>0.8+0.6</em>0.3+O*0.2)/(0.4+0.3+0.2)</p><p>4、动态加权法:计算x/Y/z三种召回策略的CTR，作为每天更新的动态加权</p><p>5、机器学习权重法:逻辑回归LR分类模型预先离线算好各种召回的权重，然后做加权召回</p></blockquote><h2 id="推荐系统-AB-Test">推荐系统  AB Test</h2><ul><li><p>定义</p><blockquote><ol><li>AB测试是一种向产品的不同受众展示同一内容的2个或多个变体，并比较哪个变体带来了更多转化的做法。</li><li>AB测试是转化率优化过程的重要方法之一，使用它来收集定性和定量的用户见解，来了解潜在客户并根据该数据优化转化渠道。</li></ol></blockquote></li><li><p>必要性</p><blockquote><ol><li>想要数据驱动，重点是做AB对比实验，然后模型策略、设计等不断的迭代更新;</li><li>进行低风险的修改，先在小流量测试，如果没有问题再调大流量;</li><li>实现数据统计上的重大改进，降低人工猜测、直觉决策的不确定性;</li><li>怎样证明自己做的好?工程开发职位和算法职位的重大区分，后者更能用对比数据说话</li></ol></blockquote></li></ul><h3 id="AB-Test基本架构">AB Test基本架构</h3><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230310224421.png" alt="image-20230309174152009"></p><h3 id="ab测试中常见问题">ab测试中常见问题</h3><blockquote><ol><li>不要同时运行太多测试:<br>要确定测试的优先级，一起测试太多的元素很难确定哪个元素对测试的成功或失败影响最大。</li><li>实验的流量大小:<br>流量样本的数量过小，实验结论不能使人信服</li><li>测试持续时间不能太短:<br>运行测试时间过短会导致测试失败或产生不重要的结果</li><li>无法遵循迭代过程:<br>A/B测试是一个迭代过程，每个测试都基于先前测试的结果，不管当前成功或失败，都不要停止继续AB测试</li></ol></blockquote><h1>案例</h1><h2 id="1-Netflix经典推荐系统架构">1. Netflix经典推荐系统架构</h2><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230310224421.png" alt="image-20230309160440223"></p><p><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230310224420.png" alt="image-20230309160850977"></p><h1>智能推荐系统未来展望</h1><h2 id="CCF-C³活动第十八期：智能推荐与搜索，2023年3月30日周四（18-00-21-30），小红书北京举行">CCF C³活动第十八期：智能推荐与搜索，2023年3月30日周四（18:00-21:30），小红书北京举行</h2><h3 id="newbing-，AIGC-大模型的冲击">newbing  ，AIGC,  大模型的冲击</h3><ol><li>对于网站盈利，网站存活的影响</li><li>对于广告商认定广告有效程度的认定</li><li>智能推荐可能的更大的发展<ul><li>利用该大模型对于用户，心智捕捉更强的能力；能够真正做到智能推荐，给用户真正有用的推荐</li></ul></li><li>生成式的大模型，需要关注使用场景<ul><li>比如，风控领域，需要的是fact</li><li>适配大模型结合个人信息，个性化</li></ul></li><li>存疑，未来推荐、搜索的形态</li><li>过去的搜索推荐，都是基于用户点击行为驱动的算法分发模式，走向用户<br>行为加内容理解，双轮并驱的内容分发模式</li><li>搜推一体化</li></ol><h3 id="在智能信息检索方面，如何发现并去除用户反馈中的偏差">在智能信息检索方面，如何发现并去除用户反馈中的偏差</h3><ol><li><p>因果分析</p><blockquote><ul><li>假设；因果图</li></ul></blockquote><blockquote><p>总体是基于一种假设，没有对系统进行干预</p><p>搜推一体化不一定</p><p>但是搜索数据可以帮推荐，推荐的数据可以帮搜索</p><ul><li>是否可以进行干预，自然干预的方法<ul><li>不付出太多的代价，把搜索的query当成对推荐的一种干预</li><li>利用微观经济学中的一个概念，工具变量</li></ul></li><li>稍微引入外部的知识进行干预，</li><li>是否干预，都是为了实现无偏估计</li></ul></blockquote></li></ol><h3 id="基于人类反馈的强化学习，LHF，对推荐有哪些启发">基于人类反馈的强化学习，LHF，对推荐有哪些启发</h3><p>郝建业老师</p><p>传统强化学习的优化目标多是点击，时长</p><ul><li><p>openai,   训练的三步，强化学习的面临的挑战</p><blockquote><p>ss</p></blockquote></li><li><p>如何进行强化学习梯度的训练</p></li><li><p>ctr预估，早已经利用了强化学习的思想《</p><blockquote><p>当前推荐，有偏</p><p>强化学习 很难落地推荐</p><p>用户心智应该是一个序列决策问题</p><p>推荐领域的用户大模型，数据打通</p><p>数据质量</p></blockquote></li></ul><h3 id="用户隐私，AIGC，-计算所，敖翔老师">用户隐私，AIGC，--计算所，敖翔老师</h3><p>菁蓉领域反欺诈领域</p><p>对抗性，其内的机理和范式是存在的</p><h3 id="小红书，为什么脱颖而出-–-小红书技术负责人，夏侯">小红书，为什么脱颖而出 – 小红书技术负责人，夏侯</h3><ul><li><p>UGC社区而不是PGC社区</p></li><li><p>希望是一个去中心化的流量分发机制</p></li><li><p>交互和消费之间是怎样的trade-off，又是怎样建模</p></li><li><p>小红书内容的多样性</p></li><li><p>可行的流量货币化的机制</p></li></ul><p>关于搜索</p><ul><li>当前的搜索非常  中长尾，优化难度大</li><li>传统的搜索流量集中在头部</li><li>chatgpt，</li><li>搜索，推荐互相finetuning</li></ul><h3 id=""></h3><h3 id="已有研究，把各类推荐任务统一到语言生成任务框架中，下一代推荐系统是否会形成大一统">已有研究，把各类推荐任务统一到语言生成任务框架中，下一代推荐系统是否会形成大一统</h3><p>大模型+插件，会不会形成新的OS，以后的app都变成插件</p><ul><li><p>传统的搜索、推荐，是使用大量的用户数据，区训练模型，使得模型能够反映用户在使用这两种工具所自然的表现，喜好等等</p></li><li><p>而GPT的训练方式，还是使用了语言的特点</p></li><li><p>GPT  应用到搜索推荐的话，对应于搜索、推荐的行为做对齐</p><blockquote><p>不同推荐场景的关联性有多大</p></blockquote></li></ul><h3 id="大语言模型的开发和训练，需要极大的资源和算力">大语言模型的开发和训练，需要极大的资源和算力</h3><h1>参考资料</h1><ol><li><a href="https://www.bilibili.com/video/BV1Dz411B7wd?p=4&amp;spm_id_from=pageDriver&amp;vd_source=079f268ceb076dc167768a4865b01eaa">https://www.bilibili.com/video/BV1Dz411B7wd?p=4&amp;spm_id_from=pageDriver&amp;vd_source=079f268ceb076dc167768a4865b01eaa</a></li><li><a href="https://www.bilibili.com/video/BV1BL411m7A7/?spm_id_from=333.337.search-card.all.click&amp;vd_source=079f268ceb076dc167768a4865b01eaa">https://www.bilibili.com/video/BV1BL411m7A7/?spm_id_from=333.337.search-card.all.click&amp;vd_source=079f268ceb076dc167768a4865b01eaa</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 推荐算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
