<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>计算机启动-围绕内存的所有操作 | JLChenBlog</title><meta name="author" content="陈加乐"><meta name="copyright" content="陈加乐"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机启动-围绕内存的所有操作">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机启动-围绕内存的所有操作">
<meta property="og:url" content="https://jlchentop.github.io/posts/20231129214044-734bc566.html">
<meta property="og:site_name" content="JLChenBlog">
<meta property="og:description" content="计算机启动-围绕内存的所有操作">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/2023/11/20231118-173519.jpg">
<meta property="article:published_time" content="2023-11-29T13:40:44.000Z">
<meta property="article:modified_time" content="2023-12-18T14:15:05.154Z">
<meta property="article:author" content="陈加乐">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/2023/11/20231118-173519.jpg"><link rel="shortcut icon" href="/img/moon_JLC.ico"><link rel="canonical" href="https://jlchentop.github.io/posts/20231129214044-734bc566.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: 陈加乐","link":"链接: ","source":"来源: JLChenBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机启动-围绕内存的所有操作',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-18 22:15:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230313111525.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/2023/11/20231118-173519.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="JLChenBlog"><img class="site-icon" src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230313111525.png"/><span class="site-name">JLChenBlog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机启动-围绕内存的所有操作</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-29T13:40:44.000Z" title="发表于 2023-11-29 21:40:44">2023-11-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-18T14:15:05.154Z" title="更新于 2023-12-18 22:15:05">2023-12-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机启动-围绕内存的所有操作"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>计算机启动-围绕内存的所有操作</p>
<h1 id="计算机-启动过程">计算机 启动过程</h1>
<p>每次加电后，CPU总是到内存（其实是只读存储器）里面预设的位置拿第一条指令、并从这个位置开始，一条条执行后面的一整块代码。</p>
<p>这段指令是主板上固件程序的一部分，这个固件程序负责检查核心硬件（内存、显卡等）是否正常；</p>
<p>在机器加电的时候，首先会进行CPU的初始化，reset一些寄存器。在i8086架构中，cs(code segment register, 代码段寄存器)会被初始化成<code>0xf000</code>, pc(program counter, 程序计数寄存器)会被初始化为<code>0xfff0</code>, 也就是说CPU的第一条指令实在cs:pc处取指的。这条指令会跳转到BIOS程序执行入口，BIOS程序进行初始化和自检工作后，加载位于主引导扇区中的bootloader, 再把控制权交给bootloader , bootloader又通过一定的规则，同时完成从实模式到保护模式的转换，加载位于磁盘上的操作系统内核，最后把控制权交给操作系统内核，完成加载工作。</p>
<blockquote>
<p>注：cs:pc在i8086实模式下对应的物理地址是<code>(cs &lt;&lt; 4) + pc = 0xf0000 + 0xfff0 = 0xffff0</code></p>
</blockquote>
<p>可以分为以下几个步骤：</p>
<ol>
<li>
<p>加电自检（Power-On Self-Test，POST）：当计算机通电时，硬件设备会进行自检，包括检查内存、处理器、硬盘等是否正常工作。这个过程通常只需要几秒钟。</p>
</li>
<li>
<p>启动引导加载程序（Bootloader）：计算机会加载引导加载程序，例如GRUB（GRand Unified Bootloader）或LILO（Linux Loader）。这些引导加载程序位于硬盘的引导扇区，它们负责加载操作系统内核。</p>
</li>
<li>
<p>加载内核（Kernel）：引导加载程序会加载Linux内核，将其加载到内存中。内核是操作系统的核心部分，负责管理硬件设备、内存、文件系统等。</p>
</li>
<li>
<p>初始化（Initialization）：内核加载后，会执行一系列初始化任务。这些任务包括初始化设备驱动程序、创建进程、设置系统参数等。</p>
</li>
<li>
<p>运行init进程：在初始化完成后，内核会启动init进程，它是用户空间的第一个进程。init进程会读取配置文件（如/etc/inittab或/etc/init.d/）并启动其他系统进程和服务。</p>
</li>
<li>
<p>启动系统服务：init进程会根据配置文件启动各种系统服务，如网络服务、登录管理器、时间同步等。</p>
</li>
<li>
<p>用户登录：一旦系统服务启动完成，用户可以通过登录界面或命令行登录系统。</p>
</li>
</ol>
<p>总结起来，Linux启动过程包括硬件自检、引导加载程序加载内核、内核初始化、启动init进程、启动系统服务和用户登录。这个过程通常在几秒钟到几分钟之间，具体时间取决于硬件配置和系统设置。</p>
<h1 id="所有和内存相关的操作">所有和内存相关的操作</h1>
<h2 id="1-加电自检阶段的内存检测">1. 加电自检阶段的内存检测</h2>
<p>加电自检（POST）阶段的内存检测主要包括以下几个部分：</p>
<ol>
<li>
<p>初始化内存控制器：在开始内存检测之前，计算机会对内存控制器进行初始化，以确保它能够正确地与内存模块进行通信。</p>
</li>
<li>
<p>写入和读取测试模式：计算机会向内存中写入特定的测试模式和数据序列，然后再读取并验证这些数据。这可以帮助检测内存模块是否能够正确地接收和存储数据。</p>
</li>
<li>
<p>内存地址线测试：计算机会逐个测试内存地址线，确保每根地址线都能够正确地传输地址信息。这可以帮助检测内存地址线是否存在连接问题或者其他故障。</p>
</li>
<li>
<p>数据线测试：计算机会逐个测试内存数据线，确保每根数据线都能够正确地传输数据。这可以帮助检测内存数据线是否存在连接问题或者其他故障。</p>
</li>
<li>
<p>内存模块大小和类型检测：计算机会检测安装的内存模块的大小和类型，并与系统配置进行匹配。这可以帮助确保内存模块的兼容性和一致性。</p>
</li>
</ol>
<p>具体的内存检测过程可能会因计算机硬件和固件的不同而有所差异。一般来说，计算机会在启动时进行这些检测，并将结果显示在屏幕上或通过声音信号进行通知。如果检测过程中发现内存问题，计算机可能会停止启动并提示用户采取进一步的措施，如更换或重新插拔内存模块。</p>
<h2 id="2-bios把引导加载程序放入内存">2. bios把引导加载程序放入内存</h2>
<ol>
<li>
<p>BIOS找到第一个可引导的设备、读取该设备的引导扇区（boot sector），一般位于硬盘的第一个物理扇区，是一个512字节大小的区域，其中包含了引导加载程序的代码。</p>
</li>
<li>
<p>BIOS将引导设备的第一个扇区加载到内存中的特定位置是内存地址0x7C00处。<br>
这个位置是一个固定的位置，被用作引导加载程序的入口点。一旦引导扇区被加载到这个内存位置，CPU就会开始执行这个代码，从而启动操作系统的引导过程。</p>
</li>
<li>
<p>为什么是 内存地址0x7C00处？<br>
参考<a target="_blank" rel="noopener" href="https://www.glamenv-septzen.net/en/view/6">为什么 BIOS 将 MBR 加载到 x0 中的 7x00C86 中？- Glamenv-Septzen.net（zh）</a></p>
<blockquote>
<p>0x7c00这个地址来自Intel的第一代个人电脑芯片8088，之后的CPU为了保持兼容就一直使用这个地址。</p>
<p>1981年8月，IBM公司最早的个人电脑 IBM PC 5150 上市，就用了这个芯片。当时搭配的操作系统是86-DOS.这个操作需要的内存最少是32KB。内存地址从0x0000开始编号，32KB的内存就是 0x0000~0x7FFF。</p>
<p>8088芯片本身需要占用 0x0000~0x03FF，用来保存各种中断处理程序的储存位置。（主引导记录本身就是中断信号INT 19h的处理程序）。所以，内存只剩下 0x0400~0x7FFF可以使用。</p>
<p>为了把尽量多的连续内存留给操作系统，主引导记录就被放到了内存地址的尾部。由于一个扇区是512 字节，主引导扇区本身也会产生数据，需要另外留出512字节保存。所以，它的预留位置就变成了：</p>
<p>0x7FFF - 512 - 512 + 1 = 0x7c00，也即 32KB - 1KB。</p>
<p>所以0x7c00 就是这样来的。</p>
</blockquote>
</li>
</ol>
<h2 id="3-引导加载程序对内存进行一些初始化操作">3. 引导加载程序对内存进行一些初始化操作</h2>
<p>引导加载程序在控制权转交给操作系统之前，需要对内存进行基本的初始化。下面是一些常见的内存初始化操作：</p>
<ol>
<li>
<p>设置堆栈（Stack Setup）：堆栈是用于存储函数调用和局部变量等临时数据的一种数据结构。引导加载程序需要设置堆栈指针，以确保在后续的代码执行过程中能够正确地使用堆栈。</p>
<blockquote>
<p>具体来说，堆栈指的是一块内存区域，用于存储函数调用时的返回地址、局部变量等信息。堆栈的设置包括两个步骤：</p>
<ol>
<li>确定堆栈的起始地址；</li>
<li>将堆栈指针（Stack Pointer）初始化为堆栈的起始地址。</li>
</ol>
<p>在启动时，处理器会将堆栈指针（SP，Stack Pointer）初始化为一个特定的值，通常是内存末端的地址。<br>
然后，引导加载程序会根据系统的需要，设置一个新的堆栈指针，以便可用于进一步的操作。<br>
具体的做法是将新的堆栈指针值存储到处理器的堆栈指针寄存器（SP register）中，这样处理器在执行指令或调用函数时，就会使用新的堆栈指针。这个过程通常被称为 “堆栈初始化” 或 “堆栈设置”。</p>
</blockquote>
</li>
<li>
<p>清零寄存器（Zero Registers）：为了确保在运行操作系统之前，所有寄存器中的值都是可控的，引导加载程序会将所有寄存器清零，这样可以避免旧数据的干扰。</p>
</li>
<li>
<p>建立内存映射表（Memory Mapping）：引导加载程序需要建立内存映射表，将物理内存地址映射到虚拟内存地址。这样操作系统在运行时就能够正确访问和管理内存。</p>
<blockquote>
<p>在引导加载程序初始化内存时，通常会执行以下步骤以建立内存映射表（Memory Mapping）：</p>
<ol>
<li>
<p>设置段寄存器：引导加载程序使用实模式来操作系统启动的早期阶段。在实模式下，内存被分为段（Segment）和偏移量（Offset）。程序需要设置段寄存器，以正确访问内存。</p>
</li>
<li>
<p>初始化全局描述符表（Global Descriptor Table，GDT）：GDT是一个数据结构，用于定义不同的内存段的属性和位置。引导加载程序需要初始化GDT，以便操作系统能够正确使用内存。</p>
</li>
<li>
<p>启用分页机制（Paging）：分页机制是一种将物理内存映射到虚拟内存的技术。引导加载程序需要启用分页机制，以便操作系统可以使用虚拟内存管理和地址转换。</p>
</li>
<li>
<p>设置页表和页目录：页表和页目录是分页机制中的关键数据结构，用于映射虚拟地址到物理地址。引导加载程序需要创建并初始化页表和页目录，以建立正确的内存映射关系。</p>
</li>
<li>
<p>启用内存保护：引导加载程序可能会设置内存保护功能，例如开启写保护，以防止对关键内存区域的非法写操作。</p>
</li>
</ol>
<p>这些步骤可以确保内存的基本初始化和正确映射，为操作系统的正常运行提供必要的环境。具体的实现方式可能因操作系统和硬件平台而有所不同。</p>
</blockquote>
</li>
<li>
<p>加载中断向量表（Interrupt Vector Table）：中断向量表存储了各种硬件和软件中断的入口点，引导加载程序需要加载和设置正确的中断向量表，以确保操作系统能够正确响应中断。<br>
这里加载的 初级的中断向量表，还有一些高级中断向量表由操作系统负负责加载</p>
<blockquote>
<p>对内存进行基本的初始化，包括加载中断向量表（Interrupt Vector Table），可以通过以下步骤来完成：</p>
<ol>
<li>
<p>确定中断向量表的位置：中断向量表是一个存储中断处理程序入口地址的数据结构。它通常位于内存的固定位置，例如0x0000:0x0000处（实模式下）或0x00000000处（保护模式下）。</p>
</li>
<li>
<p>加载中断向量表：将中断向量表的内容加载到确定的位置。这可能涉及将中断处理程序的入口地址写入适当的内存位置。在实模式下，中断向量表是一个简单的数组；在保护模式下，中断向量表是一个数据结构，包含每个中断的处理程序地址。</p>
</li>
<li>
<p>设置中断描述符表（Interrupt Descriptor Table，IDT）：在保护模式下，中断向量表实际上是IDT的一部分。引导加载程序需要初始化IDT，并将其指向中断向量表的位置。</p>
</li>
<li>
<p>启用中断：在初始化完中断向量表和IDT后，引导加载程序需要启用中断，以便操作系统可以正确处理各种中断事件。</p>
</li>
</ol>
<p>这些步骤将确保中断向量表被正确加载到内存，并为操作系统提供中断处理的基本框架。具体的实现方式可能因操作系统和硬件平台而有所不同。</p>
</blockquote>
</li>
</ol>
<h2 id="4-加载内核">4. 加载内核</h2>
<p>引导加载程序加内核，并移交控制权</p>
<p>详细步骤：</p>
<ol>
<li>内核文件被成功加载到内存中，引导加载程序会传递一些启动参数给内核，比如根文件系统的位置、内存分配信息等。接着，引导加载程序会将控制权转交给内核。此时，内核接管了对计算机硬件的控制，并开始执行自己的初始化过程。</li>
<li>内核首先会解压自身，因为内核文件通常是经过压缩的，所以在加载到内存后需要进行解压操作。</li>
<li>内核会初始化系统的核心部分，包括进程管理、内存管理、设备驱动、文件系统等。</li>
<li>内核会识别和配置计算机的硬件设备，如CPU、内存、外部设备等，并建立相应的数据结构以便系统能够与这些硬件设备进行交互。</li>
<li>接下来，内核会初始化虚拟文件系统、网络子系统和其他子系统，为用户空间程序的运行做准备。</li>
<li>内核还会启动第一个用户空间进程——init进程。这个进程是所有其他用户空间进程的祖先进程，负责系统的初始化和进程的管理。</li>
<li>一旦init进程被启动，内核的加载阶段就结束了，系统已经切换到用户空间，并开始执行用户空间的初始化和服务启动。</li>
</ol>
<p>总的来说，加载内核是Linux启动过程中非常重要的一步，它标志着系统内核开始接管对硬件的控制，并进行系统内核的初始化工作。成功加载内核后，系统将进入用户空间，并开始执行用户空间的初始化进程，为用户提供各种服务和功能。</p>
<h1 id="关键数据结构及初始化">关键数据结构及初始化</h1>
<ol>
<li>段描述符表（Global Descriptor Table，GDT）</li>
<li>中断描述符表（Interrupt Descriptor Table，IDT）</li>
<li>页目录表（Page Directory Table，PDT）</li>
</ol>
<ul>
<li>Linux0.11内核：内核会将所有页的页描述符struct page 放到全局数组mem_map[]中</li>
<li>节点使用 struct pglist_data 结构来描述。<br>
内存管理区是使用 struct zone 结构来描述的。<br>
页框是使用 struct page 结构来表示的。所有页描述符都保存在全局数组 mem_map[]</li>
</ul>
<h2 id="1-mem-init-main-memory-start-memory-end-函数-设置PDT">1.   mem_init(main_memory_start, memory_end)函数 设置PDT</h2>
<p>内核执行该函数，初始化 全局数组mem_map[]。分为内核源码区，缓冲区，主内存区</p>
<p><strong>mem_map</strong> 数组的各个位置上赋值，而且显示全部赋值为 USED 也就是 100，然后对其中一部分又赋值为了 0。</p>
<p>赋值为 100 的部分就是 USED，也就表示内存被占用，</p>
<h2 id="2-trap-init-函数-设置IDT">2. trap_init();函数 设置IDT</h2>
<p>set_trap_gate(0,&amp;divide_error);</p>
<p>设置中断处理程序到IDT中</p>
<h2 id="3-进程调度初始化，shed-init">3. 进程调度初始化，shed_init()</h2>
<p>初始化了下 TSS和 LDT;</p>
<p>TSS 叫<strong>任务状态段</strong>，就是<strong>保存和恢复进程的上下文的</strong></p>
<p>LDT 叫<strong>局部描述符表</strong>，是与 GDT 全局描述符表相对应的，内核态的代码用 GDT 里的数据段和代码段，而用户进程的代码用每个用户进程自己的 LDT 里得数据段和代码段</p>
<h2 id="4-buffer-init-long-buffer-end">4. buffer_init(long buffer_end)</h2>
<p>初始化缓冲区</p>
<h2 id="5。hd-init-硬盘初始化">5。hd_init(); 硬盘初始化</h2>
<p>设置<strong>blk_dev[]</strong> 来进行管理，每一个索引表示一个块设备。</p>
<ul>
<li>下述为计算机启动的初始步骤</li>
</ul>
<h1 id="加电自检（Power-On-Self-Test，POST）">加电自检（Power-On Self-Test，POST）</h1>
<p>加电自检是Linux启动过程的第一步，也是计算机硬件初始化的过程。在这个阶段，计算机会对硬件进行自我检测，以确保硬件正常运行。</p>
<p>具体来说，加电自检包括以下几个主要的步骤：</p>
<ol>
<li>
<p>供电检测：计算机加电后，电源单元会向主板和其他硬件组件提供电源。在此过程中，计算机会检测电源是否正常工作，以确保稳定的供电。</p>
</li>
<li>
<p>主板检测：计算机主板是各种硬件组件的连接中心。加电自检会对主板进行检测，包括检查主板上的电容、晶振、芯片组等是否正常。</p>
</li>
<li>
<p>CPU初始化：加电自检会初始化CPU，包括设置CPU的工作模式、时钟频率等。此外，还会检查CPU的缓存、指令集等功能是否正常。</p>
</li>
<li>
<p>内存检测：计算机会对安装在主板上的内存模块进行检测。它会读取内存的配置信息，如容量、频率等，并检查内存是否正常工作。</p>
</li>
<li>
<p>显卡检测：加电自检还会检测计算机中的显卡。它会读取显卡的信息，并确保显卡能够正常工作。</p>
</li>
<li>
<p>储存设备检测：计算机会检测硬盘、光驱等储存设备是否连接正常。它会读取设备的信息，并确保它们能够被正确识别和访问。</p>
</li>
<li>
<p>外部设备检测：加电自检还会检测计算机外部设备，如键盘、鼠标、打印机等。它会确保这些设备能够被正确识别和操作。</p>
</li>
<li>
<p>自检结果显示：自检过程中，计算机会将检测结果显示在屏幕上。通常会显示各个硬件组件的信息、状态和错误提示，以便用户或技术人员进行故障排除。</p>
</li>
</ol>
<p>加电自检是Linux启动过程中非常重要的一步，它确保了计算机硬件的正常工作。如果在自检过程中发现硬件故障或异常，计算机会通过声音提示或屏幕显示错误信息，以便用户采取相应的措施修复问题。只有当加电自检通过并确认硬件正常后，计算机才能继续进行后续的启动步骤。</p>
<h1 id="启动引导加载程序（Bootloader）">启动引导加载程序（Bootloader）</h1>
<p>启动引导加载程序是Linux启动过程的第二步，它的主要任务是在计算机启动时加载操作系统内核。在这个阶段，计算机会读取硬盘中的引导扇区，并将引导加载程序加载到内存中进行执行。</p>
<p>下面是启动引导加载程序的详细步骤：</p>
<ol>
<li>
<p>开机自检完成后，计算机会通过主板上的BIOS（基本输入/输出系统）开始引导过程。BIOS是固化在主板上的一组软件，负责初始化硬件并提供基本的输入输出功能。</p>
</li>
<li>
<p>BIOS会根据预设的引导设备顺序（如硬盘、光盘、USB等）找到第一个可引导的设备。</p>
</li>
<li>
<p>BIOS会读取该设备的引导扇区（boot sector），引导扇区位于硬盘的第一个物理扇区。引导扇区是一个512字节大小的区域，其中包含了引导加载程序的代码。</p>
</li>
<li>
<p>引导加载程序可以是GRUB（GRand Unified Bootloader）或LILO（LInux LOader）等。这些引导加载程序通常已经被安装在硬盘的引导扇区上。</p>
</li>
<li>
<p>引导加载程序会将自己的代码加载到计算机的内存中，并在控制权转交给它之前对内存进行一些基本的初始化。</p>
<blockquote>
<h3 id="引导加载程序对内存进行一些初始化操作">引导加载程序对内存进行一些初始化操作</h3>
<p>引导加载程序在控制权转交给操作系统之前，需要对内存进行基本的初始化。下面是一些常见的内存初始化操作：</p>
<ol>
<li>
<p>设置堆栈（Stack Setup）：堆栈是用于存储函数调用和局部变量等临时数据的一种数据结构。引导加载程序需要设置堆栈指针，以确保在后续的代码执行过程中能够正确地使用堆栈。</p>
</li>
<li>
<p>清零寄存器（Zero Registers）：为了确保在运行操作系统之前，所有寄存器中的值都是可控的，引导加载程序会将所有寄存器清零，这样可以避免旧数据的干扰。</p>
</li>
<li>
<p>建立内存映射表（Memory Mapping）：引导加载程序需要建立内存映射表，将物理内存地址映射到虚拟内存地址。这样操作系统在运行时就能够正确访问和管理内存。</p>
</li>
<li>
<p>加载中断向量表（Interrupt Vector Table）：中断向量表存储了各种硬件和软件中断的入口点，引导加载程序需要加载和设置正确的中断向量表，以确保操作系统能够正确响应中断。</p>
</li>
<li>
<p>设置保护模式（Enable Protected Mode）：引导加载程序可能会将计算机从实模式切换到保护模式。在保护模式下，操作系统可以更好地管理内存和处理器资源。</p>
</li>
<li>
<p>加载其他必要数据结构：引导加载程序可能会加载一些其他必要的数据结构，例如页表、段描述符等，以便操作系统能够正确地访问和管理内存。</p>
</li>
</ol>
<p>这些内存初始化操作是为了确保操作系统能够在一个干净、可控的环境中运行。具体实现这些操作的方法会根据操作系统和硬件平台的不同而有所差异。引导加载程序会根据特定的规范和约定来执行这些操作，以确保内存被正确初始化，并为操作系统的正常运行做好准备。</p>
</blockquote>
</li>
<li>
<p>引导加载程序会在内存中查找配置文件，如GRUB的配置文件是grub.cfg。配置文件包含了操作系统内核的位置、启动参数等信息。</p>
</li>
<li>
<p>引导加载程序根据配置文件的指示，定位并加载操作系统内核。内核文件通常位于硬盘的某个分区上，如/boot目录。</p>
</li>
<li>
<p>引导加载程序将内核加载到内存中的指定位置，并将控制权转交给内核，使其开始执行。</p>
</li>
</ol>
<p>启动引导加载程序是Linux启动过程中非常关键的一步，它负责从硬盘中读取引导扇区和引导加载程序的代码，并将内核加载到内存中，为后续的初始化和运行init进程做准备。通过引导加载程序，用户可以选择不同的操作系统或不同的内核进行启动，提供了灵活性和可定制性。</p>
<h1 id="加载内核（Kernel）">加载内核（Kernel）</h1>
<p>加载内核（Kernel）是Linux启动过程中的重要步骤，它涉及将操作系统内核加载到内存并启动内核以进行系统初始化。以下是加载内核的详细步骤：</p>
<ol>
<li>
<p>引导加载程序（如GRUB）在加载后，会尝试找到并加载操作系统内核。它会根据配置文件中指定的内核位置和启动参数来执行这一步骤。</p>
</li>
<li>
<p>引导加载程序会将内核文件（通常名为vmlinuz）从硬盘的指定位置加载到计算机内存中。内核文件通常位于/boot目录下的一个特定位置。</p>
</li>
<li>
<p>一旦内核文件被成功加载到内存中，引导加载程序会传递一些启动参数给内核，比如根文件系统的位置、内存分配信息等。</p>
</li>
<li>
<p>接着，引导加载程序会将控制权转交给内核。此时，内核接管了对计算机硬件的控制，并开始执行自己的初始化过程。</p>
</li>
<li>
<p>内核首先会解压自身，因为内核文件通常是经过压缩的，所以在加载到内存后需要进行解压操作。</p>
</li>
<li>
<p>内核会初始化系统的核心部分，包括进程管理、内存管理、设备驱动、文件系统等。</p>
</li>
<li>
<p>内核会识别和配置计算机的硬件设备，如CPU、内存、外部设备等，并建立相应的数据结构以便系统能够与这些硬件设备进行交互。</p>
</li>
<li>
<p>接下来，内核会初始化虚拟文件系统、网络子系统和其他子系统，为用户空间程序的运行做准备。</p>
</li>
<li>
<p>内核还会启动第一个用户空间进程——init进程。这个进程是所有其他用户空间进程的祖先进程，负责系统的初始化和进程的管理。</p>
</li>
<li>
<p>一旦init进程被启动，内核的加载阶段就结束了，系统已经切换到用户空间，并开始执行用户空间的初始化和服务启动。</p>
</li>
</ol>
<p>总的来说，加载内核是Linux启动过程中非常重要的一步，它标志着系统内核开始接管对硬件的控制，并进行系统内核的初始化工作。成功加载内核后，系统将进入用户空间，并开始执行用户空间的初始化进程，为用户提供各种服务和功能。</p>
<h1 id="reference">reference</h1>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.glamenv-septzen.net/en/view/6">为什么 BIOS 将 MBR 加载到 x0 中的 7x00C86 中？- Glamenv-Septzen.net（zh）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ithome.com/0/644/055.htm">Linux 0.11 第一回 | 最开始的两行代码 - IT之家 (ithome.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ithome.com/0/644/371.htm">Linux 0.11 第 2 回 | 从 0x7c00 到 0x9000 - IT之家 (ithome.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dibingfa/flash-linux0.11-talk">dibingfa/flash-linux0.11-talk: 你管这破玩意叫操作系统源码 — 像小说一样品读 Linux 0.11 核心代码 (github.com)</a></li>
<li></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://JLChenTop.github.io">陈加乐</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jlchentop.github.io/posts/20231129214044-734bc566.html">https://jlchentop.github.io/posts/20231129214044-734bc566.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://JLChenTop.github.io" target="_blank">JLChenBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/2023/11/20231118-173519.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20231129100234-5ccaa8ed.html" title="系统性能量化分析-8-并发同步"><img class="cover" src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230313140810.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">系统性能量化分析-8-并发同步</div></div></a></div><div class="next-post pull-right"><a href="/posts/20231213113939-8506dd65.html" title="高级操作系统-do_page_fault"><img class="cover" src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230313140810.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">高级操作系统-do_page_fault</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20231011112523-e9939020.html" title="Unikernels-library operating systems for the cloud"><img class="cover" src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230313113133.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-10-24</div><div class="title">Unikernels-library operating systems for the cloud</div></div></a></div><div><a href="/posts/20231213113939-8506dd65.html" title="高级操作系统-do_page_fault"><img class="cover" src="https://aliyun-photo-bucket.oss-cn-beijing.aliyuncs.com/img/202320230313140810.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-12-18</div><div class="title">高级操作系统-do_page_fault</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">计算机 启动过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E5%92%8C%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">所有和内存相关的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8A%A0%E7%94%B5%E8%87%AA%E6%A3%80%E9%98%B6%E6%AE%B5%E7%9A%84%E5%86%85%E5%AD%98%E6%A3%80%E6%B5%8B"><span class="toc-number">2.1.</span> <span class="toc-text">1. 加电自检阶段的内存检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-bios%E6%8A%8A%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F%E6%94%BE%E5%85%A5%E5%86%85%E5%AD%98"><span class="toc-number">2.2.</span> <span class="toc-text">2. bios把引导加载程序放入内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F%E5%AF%B9%E5%86%85%E5%AD%98%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%BA%9B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.</span> <span class="toc-text">3. 引导加载程序对内存进行一些初始化操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8"><span class="toc-number">2.4.</span> <span class="toc-text">4. 加载内核</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">关键数据结构及初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-mem-init-main-memory-start-memory-end-%E5%87%BD%E6%95%B0-%E8%AE%BE%E7%BD%AEPDT"><span class="toc-number">3.1.</span> <span class="toc-text">1.   mem_init(main_memory_start, memory_end)函数 设置PDT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-trap-init-%E5%87%BD%E6%95%B0-%E8%AE%BE%E7%BD%AEIDT"><span class="toc-number">3.2.</span> <span class="toc-text">2. trap_init();函数 设置IDT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8Cshed-init"><span class="toc-number">3.3.</span> <span class="toc-text">3. 进程调度初始化，shed_init()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-buffer-init-long-buffer-end"><span class="toc-number">3.4.</span> <span class="toc-text">4. buffer_init(long buffer_end)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%82hd-init-%E7%A1%AC%E7%9B%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.5.</span> <span class="toc-text">5。hd_init(); 硬盘初始化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A0%E7%94%B5%E8%87%AA%E6%A3%80%EF%BC%88Power-On-Self-Test%EF%BC%8CPOST%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">加电自检（Power-On Self-Test，POST）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F%EF%BC%88Bootloader%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">启动引导加载程序（Bootloader）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F%E5%AF%B9%E5%86%85%E5%AD%98%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%BA%9B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">5.0.1.</span> <span class="toc-text">引导加载程序对内存进行一些初始化操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%EF%BC%88Kernel%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">加载内核（Kernel）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#reference"><span class="toc-number">7.</span> <span class="toc-text">reference</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By 陈加乐</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://jlchentop.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadGiscus () {
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  const config = Object.assign({
    src: 'https://giscus.app/client.js',
    'data-repo': 'JLChenTop/giscus',
    'data-repo-id': 'R_kgDOKifXpA',
    'data-category-id': 'DIC_kwDOKifXpM4CaRTV',
    'data-mapping': 'pathname',
    'data-theme': nowTheme,
    'data-reactions-enabled': '1',
    crossorigin: 'anonymous',
    async: true
  },null)

  let ele = document.createElement('script')
  for (let key in config) {
    ele.setAttribute(key, config[key])
  }
  document.getElementById('giscus-wrap').insertAdjacentElement('afterbegin',ele)
}

function changeGiscusTheme () {
  const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  function sendMessage(message) {
    const iframe = document.querySelector('iframe.giscus-frame');
    if (!iframe) return;
    iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }

  sendMessage({
    setConfig: {
      theme: theme
    }
  });
}

if ('Giscus' === 'Giscus' || !false) {
  if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
  else loadGiscus()
} else {
  function loadOtherComment () {
    loadGiscus()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="I,LOVE,YOU" data-fontsize="30px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>